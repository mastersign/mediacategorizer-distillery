<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="A Clojure application to filter the most relevant words from speech recognition results." name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{display:inline;font-size:34px;}h2.project-version{display:inline;margin-left:10px;margin-top:0;font-size:18px;}.toc-link{margin-left:10px;color:#252519;font-size:12px;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{margin:0;font-size:34px;}.docs-header{margin-bottom:25px;padding-bottom:10px;border-bottom:dotted #aaa 1px;}.toc h1{font-size:24px;}.toc{margin-bottom:40px;border-bottom:solid #bbb 1px;}.toc ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.toc li{padding-left:0;list-style-type:none;}.dependencies{}.dependencies table{border:none;width:99.99%;margin-left:20px;font-size:16px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.plugins li{padding-left:0;list-style-type:none;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;text-align:right;overflow:hidden;top:10px;right:20px;height:20px;}#floating-toc li{margin:0;padding:0;list-style-type:none;}</style><style type="text/css">body{margin:0;padding:0;color:#252519;font-size:16px;background-color:#F5F5FF;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;}h1{margin-top:0;font-size:20px;}a.anchor{color:#252519;text-decoration:none;}a.anchor:hover{color:#5050A6;}table{margin-bottom:10px;border-bottom:solid #ddd 1px;;border-spacing:0;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{border:none;margin:0px;padding-left:55px;width:410px;padding-right:20px;vertical-align:top;max-width:410px;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;background-color:ghostWhite;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
(function(E,B){function ka(a,b,d){if(d===B&&a.nodeType===1){d=a.getAttribute("data-"+b);if(typeof d==="string"){try{d=d==="true"?true:d==="false"?false:d==="null"?null:!c.isNaN(d)?parseFloat(d):Ja.test(d)?c.parseJSON(d):d}catch(e){}c.data(a,b,d)}else d=B}return d}function U(){return false}function ca(){return true}function la(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function Ka(a){var b,d,e,f,h,l,k,o,x,r,A,C=[];f=[];h=c.data(this,this.nodeType?"events":"__events__");if(typeof h==="function")h=
h.events;if(!(a.liveFired===this||!h||!h.live||a.button&&a.type==="click")){if(a.namespace)A=RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)");a.liveFired=this;var J=h.live.slice(0);for(k=0;k<J.length;k++){h=J[k];h.origType.replace(X,"")===a.type?f.push(h.selector):J.splice(k--,1)}f=c(a.target).closest(f,a.currentTarget);o=0;for(x=f.length;o<x;o++){r=f[o];for(k=0;k<J.length;k++){h=J[k];if(r.selector===h.selector&&(!A||A.test(h.namespace))){l=r.elem;e=null;if(h.preType==="mouseenter"||
h.preType==="mouseleave"){a.type=h.preType;e=c(a.relatedTarget).closest(h.selector)[0]}if(!e||e!==l)C.push({elem:l,handleObj:h,level:r.level})}}}o=0;for(x=C.length;o<x;o++){f=C[o];if(d&&f.level>d)break;a.currentTarget=f.elem;a.data=f.handleObj.data;a.handleObj=f.handleObj;A=f.handleObj.origHandler.apply(f.elem,arguments);if(A===false||a.isPropagationStopped()){d=f.level;if(A===false)b=false;if(a.isImmediatePropagationStopped())break}}return b}}function Y(a,b){return(a&&a!=="*"?a+".":"")+b.replace(La,
"`").replace(Ma,"&")}function ma(a,b,d){if(c.isFunction(b))return c.grep(a,function(f,h){return!!b.call(f,h,f)===d});else if(b.nodeType)return c.grep(a,function(f){return f===b===d});else if(typeof b==="string"){var e=c.grep(a,function(f){return f.nodeType===1});if(Na.test(b))return c.filter(b,e,!d);else b=c.filter(b,e)}return c.grep(a,function(f){return c.inArray(f,b)>=0===d})}function na(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var e=c.data(a[d++]),f=c.data(this,
e);if(e=e&&e.events){delete f.handle;f.events={};for(var h in e)for(var l in e[h])c.event.add(this,h,e[h][l],e[h][l].data)}}})}function Oa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function oa(a,b,d){var e=b==="width"?a.offsetWidth:a.offsetHeight;if(d==="border")return e;c.each(b==="width"?Pa:Qa,function(){d||(e-=parseFloat(c.css(a,"padding"+this))||0);if(d==="margin")e+=parseFloat(c.css(a,
"margin"+this))||0;else e-=parseFloat(c.css(a,"border"+this+"Width"))||0});return e}function da(a,b,d,e){if(c.isArray(b)&&b.length)c.each(b,function(f,h){d||Ra.test(a)?e(a,h):da(a+"["+(typeof h==="object"||c.isArray(h)?f:"")+"]",h,d,e)});else if(!d&&b!=null&&typeof b==="object")c.isEmptyObject(b)?e(a,""):c.each(b,function(f,h){da(a+"["+f+"]",h,d,e)});else e(a,b)}function S(a,b){var d={};c.each(pa.concat.apply([],pa.slice(0,b)),function(){d[this]=a});return d}function qa(a){if(!ea[a]){var b=c("<"+
a+">").appendTo("body"),d=b.css("display");b.remove();if(d==="none"||d==="")d="block";ea[a]=d}return ea[a]}function fa(a){return c.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var t=E.document,c=function(){function a(){if(!b.isReady){try{t.documentElement.doScroll("left")}catch(j){setTimeout(a,1);return}b.ready()}}var b=function(j,s){return new b.fn.init(j,s)},d=E.jQuery,e=E.$,f,h=/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,l=/\S/,k=/^\s+/,o=/\s+$/,x=/\W/,r=/\d/,A=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,
C=/^[\],:{}\s]*$/,J=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,w=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,I=/(?:^|:|,)(?:\s*\[)+/g,L=/(webkit)[ \/]([\w.]+)/,g=/(opera)(?:.*version)?[ \/]([\w.]+)/,i=/(msie) ([\w.]+)/,n=/(mozilla)(?:.*? rv:([\w.]+))?/,m=navigator.userAgent,p=false,q=[],u,y=Object.prototype.toString,F=Object.prototype.hasOwnProperty,M=Array.prototype.push,N=Array.prototype.slice,O=String.prototype.trim,D=Array.prototype.indexOf,R={};b.fn=b.prototype={init:function(j,
s){var v,z,H;if(!j)return this;if(j.nodeType){this.context=this[0]=j;this.length=1;return this}if(j==="body"&&!s&&t.body){this.context=t;this[0]=t.body;this.selector="body";this.length=1;return this}if(typeof j==="string")if((v=h.exec(j))&&(v[1]||!s))if(v[1]){H=s?s.ownerDocument||s:t;if(z=A.exec(j))if(b.isPlainObject(s)){j=[t.createElement(z[1])];b.fn.attr.call(j,s,true)}else j=[H.createElement(z[1])];else{z=b.buildFragment([v[1]],[H]);j=(z.cacheable?z.fragment.cloneNode(true):z.fragment).childNodes}return b.merge(this,
j)}else{if((z=t.getElementById(v[2]))&&z.parentNode){if(z.id!==v[2])return f.find(j);this.length=1;this[0]=z}this.context=t;this.selector=j;return this}else if(!s&&!x.test(j)){this.selector=j;this.context=t;j=t.getElementsByTagName(j);return b.merge(this,j)}else return!s||s.jquery?(s||f).find(j):b(s).find(j);else if(b.isFunction(j))return f.ready(j);if(j.selector!==B){this.selector=j.selector;this.context=j.context}return b.makeArray(j,this)},selector:"",jquery:"1.4.4",length:0,size:function(){return this.length},
toArray:function(){return N.call(this,0)},get:function(j){return j==null?this.toArray():j<0?this.slice(j)[0]:this[j]},pushStack:function(j,s,v){var z=b();b.isArray(j)?M.apply(z,j):b.merge(z,j);z.prevObject=this;z.context=this.context;if(s==="find")z.selector=this.selector+(this.selector?" ":"")+v;else if(s)z.selector=this.selector+"."+s+"("+v+")";return z},each:function(j,s){return b.each(this,j,s)},ready:function(j){b.bindReady();if(b.isReady)j.call(t,b);else q&&q.push(j);return this},eq:function(j){return j===
-1?this.slice(j):this.slice(j,+j+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(N.apply(this,arguments),"slice",N.call(arguments).join(","))},map:function(j){return this.pushStack(b.map(this,function(s,v){return j.call(s,v,s)}))},end:function(){return this.prevObject||b(null)},push:M,sort:[].sort,splice:[].splice};b.fn.init.prototype=b.fn;b.extend=b.fn.extend=function(){var j,s,v,z,H,G=arguments[0]||{},K=1,Q=arguments.length,ga=false;
if(typeof G==="boolean"){ga=G;G=arguments[1]||{};K=2}if(typeof G!=="object"&&!b.isFunction(G))G={};if(Q===K){G=this;--K}for(;K<Q;K++)if((j=arguments[K])!=null)for(s in j){v=G[s];z=j[s];if(G!==z)if(ga&&z&&(b.isPlainObject(z)||(H=b.isArray(z)))){if(H){H=false;v=v&&b.isArray(v)?v:[]}else v=v&&b.isPlainObject(v)?v:{};G[s]=b.extend(ga,v,z)}else if(z!==B)G[s]=z}return G};b.extend({noConflict:function(j){E.$=e;if(j)E.jQuery=d;return b},isReady:false,readyWait:1,ready:function(j){j===true&&b.readyWait--;
if(!b.readyWait||j!==true&&!b.isReady){if(!t.body)return setTimeout(b.ready,1);b.isReady=true;if(!(j!==true&&--b.readyWait>0))if(q){var s=0,v=q;for(q=null;j=v[s++];)j.call(t,b);b.fn.trigger&&b(t).trigger("ready").unbind("ready")}}},bindReady:function(){if(!p){p=true;if(t.readyState==="complete")return setTimeout(b.ready,1);if(t.addEventListener){t.addEventListener("DOMContentLoaded",u,false);E.addEventListener("load",b.ready,false)}else if(t.attachEvent){t.attachEvent("onreadystatechange",u);E.attachEvent("onload",
b.ready);var j=false;try{j=E.frameElement==null}catch(s){}t.documentElement.doScroll&&j&&a()}}},isFunction:function(j){return b.type(j)==="function"},isArray:Array.isArray||function(j){return b.type(j)==="array"},isWindow:function(j){return j&&typeof j==="object"&&"setInterval"in j},isNaN:function(j){return j==null||!r.test(j)||isNaN(j)},type:function(j){return j==null?String(j):R[y.call(j)]||"object"},isPlainObject:function(j){if(!j||b.type(j)!=="object"||j.nodeType||b.isWindow(j))return false;if(j.constructor&&
!F.call(j,"constructor")&&!F.call(j.constructor.prototype,"isPrototypeOf"))return false;for(var s in j);return s===B||F.call(j,s)},isEmptyObject:function(j){for(var s in j)return false;return true},error:function(j){throw j;},parseJSON:function(j){if(typeof j!=="string"||!j)return null;j=b.trim(j);if(C.test(j.replace(J,"@").replace(w,"]").replace(I,"")))return E.JSON&&E.JSON.parse?E.JSON.parse(j):(new Function("return "+j))();else b.error("Invalid JSON: "+j)},noop:function(){},globalEval:function(j){if(j&&
l.test(j)){var s=t.getElementsByTagName("head")[0]||t.documentElement,v=t.createElement("script");v.type="text/javascript";if(b.support.scriptEval)v.appendChild(t.createTextNode(j));else v.text=j;s.insertBefore(v,s.firstChild);s.removeChild(v)}},nodeName:function(j,s){return j.nodeName&&j.nodeName.toUpperCase()===s.toUpperCase()},each:function(j,s,v){var z,H=0,G=j.length,K=G===B||b.isFunction(j);if(v)if(K)for(z in j){if(s.apply(j[z],v)===false)break}else for(;H<G;){if(s.apply(j[H++],v)===false)break}else if(K)for(z in j){if(s.call(j[z],
z,j[z])===false)break}else for(v=j[0];H<G&&s.call(v,H,v)!==false;v=j[++H]);return j},trim:O?function(j){return j==null?"":O.call(j)}:function(j){return j==null?"":j.toString().replace(k,"").replace(o,"")},makeArray:function(j,s){var v=s||[];if(j!=null){var z=b.type(j);j.length==null||z==="string"||z==="function"||z==="regexp"||b.isWindow(j)?M.call(v,j):b.merge(v,j)}return v},inArray:function(j,s){if(s.indexOf)return s.indexOf(j);for(var v=0,z=s.length;v<z;v++)if(s[v]===j)return v;return-1},merge:function(j,
s){var v=j.length,z=0;if(typeof s.length==="number")for(var H=s.length;z<H;z++)j[v++]=s[z];else for(;s[z]!==B;)j[v++]=s[z++];j.length=v;return j},grep:function(j,s,v){var z=[],H;v=!!v;for(var G=0,K=j.length;G<K;G++){H=!!s(j[G],G);v!==H&&z.push(j[G])}return z},map:function(j,s,v){for(var z=[],H,G=0,K=j.length;G<K;G++){H=s(j[G],G,v);if(H!=null)z[z.length]=H}return z.concat.apply([],z)},guid:1,proxy:function(j,s,v){if(arguments.length===2)if(typeof s==="string"){v=j;j=v[s];s=B}else if(s&&!b.isFunction(s)){v=
s;s=B}if(!s&&j)s=function(){return j.apply(v||this,arguments)};if(j)s.guid=j.guid=j.guid||s.guid||b.guid++;return s},access:function(j,s,v,z,H,G){var K=j.length;if(typeof s==="object"){for(var Q in s)b.access(j,Q,s[Q],z,H,v);return j}if(v!==B){z=!G&&z&&b.isFunction(v);for(Q=0;Q<K;Q++)H(j[Q],s,z?v.call(j[Q],Q,H(j[Q],s)):v,G);return j}return K?H(j[0],s):B},now:function(){return(new Date).getTime()},uaMatch:function(j){j=j.toLowerCase();j=L.exec(j)||g.exec(j)||i.exec(j)||j.indexOf("compatible")<0&&n.exec(j)||
[];return{browser:j[1]||"",version:j[2]||"0"}},browser:{}});b.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(j,s){R["[object "+s+"]"]=s.toLowerCase()});m=b.uaMatch(m);if(m.browser){b.browser[m.browser]=true;b.browser.version=m.version}if(b.browser.webkit)b.browser.safari=true;if(D)b.inArray=function(j,s){return D.call(s,j)};if(!/\s/.test("\u00a0")){k=/^[\s\xA0]+/;o=/[\s\xA0]+$/}f=b(t);if(t.addEventListener)u=function(){t.removeEventListener("DOMContentLoaded",u,
false);b.ready()};else if(t.attachEvent)u=function(){if(t.readyState==="complete"){t.detachEvent("onreadystatechange",u);b.ready()}};return E.jQuery=E.$=b}();(function(){c.support={};var a=t.documentElement,b=t.createElement("script"),d=t.createElement("div"),e="script"+c.now();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var f=d.getElementsByTagName("*"),h=d.getElementsByTagName("a")[0],l=t.createElement("select"),
k=l.appendChild(t.createElement("option"));if(!(!f||!f.length||!h)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(h.getAttribute("style")),hrefNormalized:h.getAttribute("href")==="/a",opacity:/^0.55$/.test(h.style.opacity),cssFloat:!!h.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:k.selected,deleteExpando:true,optDisabled:false,checkClone:false,
scriptEval:false,noCloneEvent:true,boxModel:null,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableHiddenOffsets:true};l.disabled=true;c.support.optDisabled=!k.disabled;b.type="text/javascript";try{b.appendChild(t.createTextNode("window."+e+"=1;"))}catch(o){}a.insertBefore(b,a.firstChild);if(E[e]){c.support.scriptEval=true;delete E[e]}try{delete b.test}catch(x){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function r(){c.support.noCloneEvent=
false;d.detachEvent("onclick",r)});d.cloneNode(true).fireEvent("onclick")}d=t.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=t.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var r=t.createElement("div");r.style.width=r.style.paddingLeft="1px";t.body.appendChild(r);c.boxModel=c.support.boxModel=r.offsetWidth===2;if("zoom"in r.style){r.style.display="inline";r.style.zoom=
1;c.support.inlineBlockNeedsLayout=r.offsetWidth===2;r.style.display="";r.innerHTML="<div style='width:4px;'></div>";c.support.shrinkWrapBlocks=r.offsetWidth!==2}r.innerHTML="<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";var A=r.getElementsByTagName("td");c.support.reliableHiddenOffsets=A[0].offsetHeight===0;A[0].style.display="";A[1].style.display="none";c.support.reliableHiddenOffsets=c.support.reliableHiddenOffsets&&A[0].offsetHeight===0;r.innerHTML="";t.body.removeChild(r).style.display=
"none"});a=function(r){var A=t.createElement("div");r="on"+r;var C=r in A;if(!C){A.setAttribute(r,"return;");C=typeof A[r]==="function"}return C};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=f=h=null}})();var ra={},Ja=/^(?:\{.*\}|\[.*\])$/;c.extend({cache:{},uuid:0,expando:"jQuery"+c.now(),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},data:function(a,b,d){if(c.acceptData(a)){a=a==E?ra:a;var e=a.nodeType,f=e?a[c.expando]:null,h=
c.cache;if(!(e&&!f&&typeof b==="string"&&d===B)){if(e)f||(a[c.expando]=f=++c.uuid);else h=a;if(typeof b==="object")if(e)h[f]=c.extend(h[f],b);else c.extend(h,b);else if(e&&!h[f])h[f]={};a=e?h[f]:h;if(d!==B)a[b]=d;return typeof b==="string"?a[b]:a}}},removeData:function(a,b){if(c.acceptData(a)){a=a==E?ra:a;var d=a.nodeType,e=d?a[c.expando]:a,f=c.cache,h=d?f[e]:e;if(b){if(h){delete h[b];d&&c.isEmptyObject(h)&&c.removeData(a)}}else if(d&&c.support.deleteExpando)delete a[c.expando];else if(a.removeAttribute)a.removeAttribute(c.expando);
else if(d)delete f[e];else for(var l in a)delete a[l]}},acceptData:function(a){if(a.nodeName){var b=c.noData[a.nodeName.toLowerCase()];if(b)return!(b===true||a.getAttribute("classid")!==b)}return true}});c.fn.extend({data:function(a,b){var d=null;if(typeof a==="undefined"){if(this.length){var e=this[0].attributes,f;d=c.data(this[0]);for(var h=0,l=e.length;h<l;h++){f=e[h].name;if(f.indexOf("data-")===0){f=f.substr(5);ka(this[0],f,d[f])}}}return d}else if(typeof a==="object")return this.each(function(){c.data(this,
a)});var k=a.split(".");k[1]=k[1]?"."+k[1]:"";if(b===B){d=this.triggerHandler("getData"+k[1]+"!",[k[0]]);if(d===B&&this.length){d=c.data(this[0],a);d=ka(this[0],a,d)}return d===B&&k[1]?this.data(k[0]):d}else return this.each(function(){var o=c(this),x=[k[0],b];o.triggerHandler("setData"+k[1]+"!",x);c.data(this,a,b);o.triggerHandler("changeData"+k[1]+"!",x)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var e=
c.data(a,b);if(!d)return e||[];if(!e||c.isArray(d))e=c.data(a,b,c.makeArray(d));else e.push(d);return e}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),e=d.shift();if(e==="inprogress")e=d.shift();if(e){b==="fx"&&d.unshift("inprogress");e.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===B)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,
a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var sa=/[\n\t]/g,ha=/\s+/,Sa=/\r/g,Ta=/^(?:href|src|style)$/,Ua=/^(?:button|input)$/i,Va=/^(?:button|input|object|select|textarea)$/i,Wa=/^a(?:rea)?$/i,ta=/^(?:radio|checkbox)$/i;c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",
colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};c.fn.extend({attr:function(a,b){return c.access(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(x){var r=c(this);r.addClass(a.call(this,x,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===
1)if(f.className){for(var h=" "+f.className+" ",l=f.className,k=0,o=b.length;k<o;k++)if(h.indexOf(" "+b[k]+" ")<0)l+=" "+b[k];f.className=c.trim(l)}else f.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(o){var x=c(this);x.removeClass(a.call(this,o,x.attr("class")))});if(a&&typeof a==="string"||a===B)for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===1&&f.className)if(a){for(var h=(" "+f.className+" ").replace(sa," "),
l=0,k=b.length;l<k;l++)h=h.replace(" "+b[l]+" "," ");f.className=c.trim(h)}else f.className=""}return this},toggleClass:function(a,b){var d=typeof a,e=typeof b==="boolean";if(c.isFunction(a))return this.each(function(f){var h=c(this);h.toggleClass(a.call(this,f,h.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var f,h=0,l=c(this),k=b,o=a.split(ha);f=o[h++];){k=e?k:!l.hasClass(f);l[k?"addClass":"removeClass"](f)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,
"__className__",this.className);this.className=this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(sa," ").indexOf(a)>-1)return true;return false},val:function(a){if(!arguments.length){var b=this[0];if(b){if(c.nodeName(b,"option")){var d=b.attributes.value;return!d||d.specified?b.value:b.text}if(c.nodeName(b,"select")){var e=b.selectedIndex;d=[];var f=b.options;b=b.type==="select-one";
if(e<0)return null;var h=b?e:0;for(e=b?e+1:f.length;h<e;h++){var l=f[h];if(l.selected&&(c.support.optDisabled?!l.disabled:l.getAttribute("disabled")===null)&&(!l.parentNode.disabled||!c.nodeName(l.parentNode,"optgroup"))){a=c(l).val();if(b)return a;d.push(a)}}return d}if(ta.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Sa,"")}return B}var k=c.isFunction(a);return this.each(function(o){var x=c(this),r=a;if(this.nodeType===1){if(k)r=
a.call(this,o,x.val());if(r==null)r="";else if(typeof r==="number")r+="";else if(c.isArray(r))r=c.map(r,function(C){return C==null?"":C+""});if(c.isArray(r)&&ta.test(this.type))this.checked=c.inArray(x.val(),r)>=0;else if(c.nodeName(this,"select")){var A=c.makeArray(r);c("option",this).each(function(){this.selected=c.inArray(c(this).val(),A)>=0});if(!A.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},
attr:function(a,b,d,e){if(!a||a.nodeType===3||a.nodeType===8)return B;if(e&&b in c.attrFn)return c(a)[b](d);e=a.nodeType!==1||!c.isXMLDoc(a);var f=d!==B;b=e&&c.props[b]||b;var h=Ta.test(b);if((b in a||a[b]!==B)&&e&&!h){if(f){b==="type"&&Ua.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");if(d===null)a.nodeType===1&&a.removeAttribute(b);else a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&
b.specified?b.value:Va.test(a.nodeName)||Wa.test(a.nodeName)&&a.href?0:B;return a[b]}if(!c.support.style&&e&&b==="style"){if(f)a.style.cssText=""+d;return a.style.cssText}f&&a.setAttribute(b,""+d);if(!a.attributes[b]&&a.hasAttribute&&!a.hasAttribute(b))return B;a=!c.support.hrefNormalized&&e&&h?a.getAttribute(b,2):a.getAttribute(b);return a===null?B:a}});var X=/\.(.*)$/,ia=/^(?:textarea|input|select)$/i,La=/\./g,Ma=/ /g,Xa=/[^\w\s.|`]/g,Ya=function(a){return a.replace(Xa,"\\$&")},ua={focusin:0,focusout:0};
c.event={add:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(c.isWindow(a)&&a!==E&&!a.frameElement)a=E;if(d===false)d=U;else if(!d)return;var f,h;if(d.handler){f=d;d=f.handler}if(!d.guid)d.guid=c.guid++;if(h=c.data(a)){var l=a.nodeType?"events":"__events__",k=h[l],o=h.handle;if(typeof k==="function"){o=k.handle;k=k.events}else if(!k){a.nodeType||(h[l]=h=function(){});h.events=k={}}if(!o)h.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,
arguments):B};o.elem=a;b=b.split(" ");for(var x=0,r;l=b[x++];){h=f?c.extend({},f):{handler:d,data:e};if(l.indexOf(".")>-1){r=l.split(".");l=r.shift();h.namespace=r.slice(0).sort().join(".")}else{r=[];h.namespace=""}h.type=l;if(!h.guid)h.guid=d.guid;var A=k[l],C=c.event.special[l]||{};if(!A){A=k[l]=[];if(!C.setup||C.setup.call(a,e,r,o)===false)if(a.addEventListener)a.addEventListener(l,o,false);else a.attachEvent&&a.attachEvent("on"+l,o)}if(C.add){C.add.call(a,h);if(!h.handler.guid)h.handler.guid=
d.guid}A.push(h);c.event.global[l]=true}a=null}}},global:{},remove:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(d===false)d=U;var f,h,l=0,k,o,x,r,A,C,J=a.nodeType?"events":"__events__",w=c.data(a),I=w&&w[J];if(w&&I){if(typeof I==="function"){w=I;I=I.events}if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(f in I)c.event.remove(a,f+b)}else{for(b=b.split(" ");f=b[l++];){r=f;k=f.indexOf(".")<0;o=[];if(!k){o=f.split(".");f=o.shift();x=RegExp("(^|\\.)"+
c.map(o.slice(0).sort(),Ya).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(A=I[f])if(d){r=c.event.special[f]||{};for(h=e||0;h<A.length;h++){C=A[h];if(d.guid===C.guid){if(k||x.test(C.namespace)){e==null&&A.splice(h--,1);r.remove&&r.remove.call(a,C)}if(e!=null)break}}if(A.length===0||e!=null&&A.length===1){if(!r.teardown||r.teardown.call(a,o)===false)c.removeEvent(a,f,w.handle);delete I[f]}}else for(h=0;h<A.length;h++){C=A[h];if(k||x.test(C.namespace)){c.event.remove(a,r,C.handler,h);A.splice(h--,1)}}}if(c.isEmptyObject(I)){if(b=
w.handle)b.elem=null;delete w.events;delete w.handle;if(typeof w==="function")c.removeData(a,J);else c.isEmptyObject(w)&&c.removeData(a)}}}}},trigger:function(a,b,d,e){var f=a.type||a;if(!e){a=typeof a==="object"?a[c.expando]?a:c.extend(c.Event(f),a):c.Event(f);if(f.indexOf("!")>=0){a.type=f=f.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[f]&&c.each(c.cache,function(){this.events&&this.events[f]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===
8)return B;a.result=B;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(e=d.nodeType?c.data(d,"handle"):(c.data(d,"__events__")||{}).handle)&&e.apply(d,b);e=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+f]&&d["on"+f].apply(d,b)===false){a.result=false;a.preventDefault()}}catch(h){}if(!a.isPropagationStopped()&&e)c.event.trigger(a,b,e,true);else if(!a.isDefaultPrevented()){var l;e=a.target;var k=f.replace(X,""),o=c.nodeName(e,"a")&&k===
"click",x=c.event.special[k]||{};if((!x._default||x._default.call(d,a)===false)&&!o&&!(e&&e.nodeName&&c.noData[e.nodeName.toLowerCase()])){try{if(e[k]){if(l=e["on"+k])e["on"+k]=null;c.event.triggered=true;e[k]()}}catch(r){}if(l)e["on"+k]=l;c.event.triggered=false}}},handle:function(a){var b,d,e,f;d=[];var h=c.makeArray(arguments);a=h[0]=c.event.fix(a||E.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;if(!b){e=a.type.split(".");a.type=e.shift();d=e.slice(0).sort();e=RegExp("(^|\\.)"+
d.join("\\.(?:.*\\.)?")+"(\\.|$)")}a.namespace=a.namespace||d.join(".");f=c.data(this,this.nodeType?"events":"__events__");if(typeof f==="function")f=f.events;d=(f||{})[a.type];if(f&&d){d=d.slice(0);f=0;for(var l=d.length;f<l;f++){var k=d[f];if(b||e.test(k.namespace)){a.handler=k.handler;a.data=k.data;a.handleObj=k;k=k.handler.apply(this,h);if(k!==B){a.result=k;if(k===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[c.expando])return a;var b=a;a=c.Event(b);for(var d=this.props.length,e;d;){e=this.props[--d];a[e]=b[e]}if(!a.target)a.target=a.srcElement||t;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=t.documentElement;d=t.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(a.which==null&&(a.charCode!=null||a.keyCode!=null))a.which=a.charCode!=null?a.charCode:a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==B)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,Y(a.origType,a.selector),c.extend({},a,{handler:Ka,guid:a.handler.guid}))},remove:function(a){c.event.remove(this,
Y(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,d){if(c.isWindow(this))this.onbeforeunload=d},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};c.removeEvent=t.removeEventListener?function(a,b,d){a.removeEventListener&&a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent&&a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=
c.now();this[c.expando]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=ca;var a=this.originalEvent;if(a)if(a.preventDefault)a.preventDefault();else a.returnValue=false},stopPropagation:function(){this.isPropagationStopped=ca;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ca;this.stopPropagation()},isDefaultPrevented:U,isPropagationStopped:U,isImmediatePropagationStopped:U};
var va=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},wa=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?wa:va,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?wa:va)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==
"form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length){a.liveFired=B;return la("submit",this,arguments)}});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13){a.liveFired=B;return la("submit",this,arguments)}})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};if(!c.support.changeBubbles){var V,
xa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(e){return e.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},Z=function(a,b){var d=a.target,e,f;if(!(!ia.test(d.nodeName)||d.readOnly)){e=c.data(d,"_change_data");f=xa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",f);if(!(e===B||f===e))if(e!=null||f){a.type="change";a.liveFired=
B;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:Z,beforedeactivate:Z,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return Z.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return Z.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,"_change_data",xa(a))}},setup:function(){if(this.type===
"file")return false;for(var a in V)c.event.add(this,a+".specialChange",V[a]);return ia.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return ia.test(this.nodeName)}};V=c.event.special.change.filters;V.focus=V.beforeactivate}t.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.trigger(e,null,e.target)}c.event.special[b]={setup:function(){ua[b]++===0&&t.addEventListener(a,d,true)},teardown:function(){--ua[b]===
0&&t.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,e,f){if(typeof d==="object"){for(var h in d)this[b](h,e,d[h],f);return this}if(c.isFunction(e)||e===false){f=e;e=B}var l=b==="one"?c.proxy(f,function(o){c(this).unbind(o,l);return f.apply(this,arguments)}):f;if(d==="unload"&&b!=="one")this.one(d,e,f);else{h=0;for(var k=this.length;h<k;h++)c.event.add(this[h],d,l,e)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&!a.preventDefault)for(var d in a)this.unbind(d,
a[d]);else{d=0;for(var e=this.length;d<e;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,e){return this.live(b,d,e,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){var d=c.Event(a);d.preventDefault();d.stopPropagation();c.event.trigger(d,b,this[0]);return d.result}},toggle:function(a){for(var b=arguments,d=
1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(e){var f=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,f+1);e.preventDefault();return b[f].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var ya={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,e,f,h){var l,k=0,o,x,r=h||this.selector;h=h?this:c(this.context);if(typeof d===
"object"&&!d.preventDefault){for(l in d)h[b](l,e,d[l],r);return this}if(c.isFunction(e)){f=e;e=B}for(d=(d||"").split(" ");(l=d[k++])!=null;){o=X.exec(l);x="";if(o){x=o[0];l=l.replace(X,"")}if(l==="hover")d.push("mouseenter"+x,"mouseleave"+x);else{o=l;if(l==="focus"||l==="blur"){d.push(ya[l]+x);l+=x}else l=(ya[l]||l)+x;if(b==="live"){x=0;for(var A=h.length;x<A;x++)c.event.add(h[x],"live."+Y(l,r),{data:e,selector:r,handler:f,origType:l,origHandler:f,preType:o})}else h.unbind("live."+Y(l,r),f)}}return this}});
c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){c.fn[b]=function(d,e){if(e==null){e=d;d=null}return arguments.length>0?this.bind(b,d,e):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});E.attachEvent&&!E.addEventListener&&c(E).bind("unload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});
(function(){function a(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1&&!q){y.sizcache=n;y.sizset=p}if(y.nodeName.toLowerCase()===i){F=y;break}y=y[g]}m[p]=F}}}function b(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1){if(!q){y.sizcache=n;y.sizset=p}if(typeof i!=="string"){if(y===i){F=true;break}}else if(k.filter(i,
[y]).length>0){F=y;break}}y=y[g]}m[p]=F}}}var d=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,f=Object.prototype.toString,h=false,l=true;[0,0].sort(function(){l=false;return 0});var k=function(g,i,n,m){n=n||[];var p=i=i||t;if(i.nodeType!==1&&i.nodeType!==9)return[];if(!g||typeof g!=="string")return n;var q,u,y,F,M,N=true,O=k.isXML(i),D=[],R=g;do{d.exec("");if(q=d.exec(R)){R=q[3];D.push(q[1]);if(q[2]){F=q[3];
break}}}while(q);if(D.length>1&&x.exec(g))if(D.length===2&&o.relative[D[0]])u=L(D[0]+D[1],i);else for(u=o.relative[D[0]]?[i]:k(D.shift(),i);D.length;){g=D.shift();if(o.relative[g])g+=D.shift();u=L(g,u)}else{if(!m&&D.length>1&&i.nodeType===9&&!O&&o.match.ID.test(D[0])&&!o.match.ID.test(D[D.length-1])){q=k.find(D.shift(),i,O);i=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]}if(i){q=m?{expr:D.pop(),set:C(m)}:k.find(D.pop(),D.length===1&&(D[0]==="~"||D[0]==="+")&&i.parentNode?i.parentNode:i,O);u=q.expr?k.filter(q.expr,
q.set):q.set;if(D.length>0)y=C(u);else N=false;for(;D.length;){q=M=D.pop();if(o.relative[M])q=D.pop();else M="";if(q==null)q=i;o.relative[M](y,q,O)}}else y=[]}y||(y=u);y||k.error(M||g);if(f.call(y)==="[object Array]")if(N)if(i&&i.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&k.contains(i,y[g])))n.push(u[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&n.push(u[g]);else n.push.apply(n,y);else C(y,n);if(F){k(F,p,n,m);k.uniqueSort(n)}return n};k.uniqueSort=function(g){if(w){h=
l;g.sort(w);if(h)for(var i=1;i<g.length;i++)g[i]===g[i-1]&&g.splice(i--,1)}return g};k.matches=function(g,i){return k(g,null,null,i)};k.matchesSelector=function(g,i){return k(i,null,null,[g]).length>0};k.find=function(g,i,n){var m;if(!g)return[];for(var p=0,q=o.order.length;p<q;p++){var u,y=o.order[p];if(u=o.leftMatch[y].exec(g)){var F=u[1];u.splice(1,1);if(F.substr(F.length-1)!=="\\"){u[1]=(u[1]||"").replace(/\\/g,"");m=o.find[y](u,i,n);if(m!=null){g=g.replace(o.match[y],"");break}}}}m||(m=i.getElementsByTagName("*"));
return{set:m,expr:g}};k.filter=function(g,i,n,m){for(var p,q,u=g,y=[],F=i,M=i&&i[0]&&k.isXML(i[0]);g&&i.length;){for(var N in o.filter)if((p=o.leftMatch[N].exec(g))!=null&&p[2]){var O,D,R=o.filter[N];D=p[1];q=false;p.splice(1,1);if(D.substr(D.length-1)!=="\\"){if(F===y)y=[];if(o.preFilter[N])if(p=o.preFilter[N](p,F,n,y,m,M)){if(p===true)continue}else q=O=true;if(p)for(var j=0;(D=F[j])!=null;j++)if(D){O=R(D,p,j,F);var s=m^!!O;if(n&&O!=null)if(s)q=true;else F[j]=false;else if(s){y.push(D);q=true}}if(O!==
B){n||(F=y);g=g.replace(o.match[N],"");if(!q)return[];break}}}if(g===u)if(q==null)k.error(g);else break;u=g}return F};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var o=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},relative:{"+":function(g,i){var n=typeof i==="string",m=n&&!/\W/.test(i);n=n&&!m;if(m)i=i.toLowerCase();m=0;for(var p=g.length,q;m<p;m++)if(q=g[m]){for(;(q=q.previousSibling)&&q.nodeType!==1;);g[m]=n||q&&q.nodeName.toLowerCase()===
i?q||false:q===i}n&&k.filter(i,g,true)},">":function(g,i){var n,m=typeof i==="string",p=0,q=g.length;if(m&&!/\W/.test(i))for(i=i.toLowerCase();p<q;p++){if(n=g[p]){n=n.parentNode;g[p]=n.nodeName.toLowerCase()===i?n:false}}else{for(;p<q;p++)if(n=g[p])g[p]=m?n.parentNode:n.parentNode===i;m&&k.filter(i,g,true)}},"":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=i=i.toLowerCase();q=a}q("parentNode",i,p,g,m,n)},"~":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=
i=i.toLowerCase();q=a}q("previousSibling",i,p,g,m,n)}},find:{ID:function(g,i,n){if(typeof i.getElementById!=="undefined"&&!n)return(g=i.getElementById(g[1]))&&g.parentNode?[g]:[]},NAME:function(g,i){if(typeof i.getElementsByName!=="undefined"){for(var n=[],m=i.getElementsByName(g[1]),p=0,q=m.length;p<q;p++)m[p].getAttribute("name")===g[1]&&n.push(m[p]);return n.length===0?null:n}},TAG:function(g,i){return i.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,i,n,m,p,q){g=" "+g[1].replace(/\\/g,
"")+" ";if(q)return g;q=0;for(var u;(u=i[q])!=null;q++)if(u)if(p^(u.className&&(" "+u.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))n||m.push(u);else if(n)i[q]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]==="nth"){var i=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=i[1]+(i[2]||1)-0;g[3]=i[3]-0}g[0]=e++;return g},ATTR:function(g,i,n,
m,p,q){i=g[1].replace(/\\/g,"");if(!q&&o.attrMap[i])g[1]=o.attrMap[i];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,i,n,m,p){if(g[1]==="not")if((d.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,i);else{g=k.filter(g[3],i,n,true^p);n||m.push.apply(m,g);return false}else if(o.match.POS.test(g[0])||o.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===
true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,i,n){return!!k(n[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===
g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},setFilters:{first:function(g,i){return i===0},last:function(g,i,n,m){return i===m.length-1},even:function(g,i){return i%2===0},odd:function(g,i){return i%2===1},lt:function(g,i,n){return i<n[3]-0},gt:function(g,i,n){return i>n[3]-0},nth:function(g,i,n){return n[3]-
0===i},eq:function(g,i,n){return n[3]-0===i}},filter:{PSEUDO:function(g,i,n,m){var p=i[1],q=o.filters[p];if(q)return q(g,n,i,m);else if(p==="contains")return(g.textContent||g.innerText||k.getText([g])||"").indexOf(i[3])>=0;else if(p==="not"){i=i[3];n=0;for(m=i.length;n<m;n++)if(i[n]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+p)},CHILD:function(g,i){var n=i[1],m=g;switch(n){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(n===
"first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":n=i[2];var p=i[3];if(n===1&&p===0)return true;var q=i[0],u=g.parentNode;if(u&&(u.sizcache!==q||!g.nodeIndex)){var y=0;for(m=u.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++y;u.sizcache=q}m=g.nodeIndex-p;return n===0?m===0:m%n===0&&m/n>=0}},ID:function(g,i){return g.nodeType===1&&g.getAttribute("id")===i},TAG:function(g,i){return i==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===
i},CLASS:function(g,i){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(i)>-1},ATTR:function(g,i){var n=i[1];n=o.attrHandle[n]?o.attrHandle[n](g):g[n]!=null?g[n]:g.getAttribute(n);var m=n+"",p=i[2],q=i[4];return n==null?p==="!=":p==="="?m===q:p==="*="?m.indexOf(q)>=0:p==="~="?(" "+m+" ").indexOf(q)>=0:!q?m&&n!==false:p==="!="?m!==q:p==="^="?m.indexOf(q)===0:p==="$="?m.substr(m.length-q.length)===q:p==="|="?m===q||m.substr(0,q.length+1)===q+"-":false},POS:function(g,i,n,m){var p=o.setFilters[i[2]];
if(p)return p(g,n,i,m)}}},x=o.match.POS,r=function(g,i){return"\\"+(i-0+1)},A;for(A in o.match){o.match[A]=RegExp(o.match[A].source+/(?![^\[]*\])(?![^\(]*\))/.source);o.leftMatch[A]=RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[A].source.replace(/\\(\d+)/g,r))}var C=function(g,i){g=Array.prototype.slice.call(g,0);if(i){i.push.apply(i,g);return i}return g};try{Array.prototype.slice.call(t.documentElement.childNodes,0)}catch(J){C=function(g,i){var n=0,m=i||[];if(f.call(g)==="[object Array]")Array.prototype.push.apply(m,
g);else if(typeof g.length==="number")for(var p=g.length;n<p;n++)m.push(g[n]);else for(;g[n];n++)m.push(g[n]);return m}}var w,I;if(t.documentElement.compareDocumentPosition)w=function(g,i){if(g===i){h=true;return 0}if(!g.compareDocumentPosition||!i.compareDocumentPosition)return g.compareDocumentPosition?-1:1;return g.compareDocumentPosition(i)&4?-1:1};else{w=function(g,i){var n,m,p=[],q=[];n=g.parentNode;m=i.parentNode;var u=n;if(g===i){h=true;return 0}else if(n===m)return I(g,i);else if(n){if(!m)return 1}else return-1;
for(;u;){p.unshift(u);u=u.parentNode}for(u=m;u;){q.unshift(u);u=u.parentNode}n=p.length;m=q.length;for(u=0;u<n&&u<m;u++)if(p[u]!==q[u])return I(p[u],q[u]);return u===n?I(g,q[u],-1):I(p[u],i,1)};I=function(g,i,n){if(g===i)return n;for(g=g.nextSibling;g;){if(g===i)return-1;g=g.nextSibling}return 1}}k.getText=function(g){for(var i="",n,m=0;g[m];m++){n=g[m];if(n.nodeType===3||n.nodeType===4)i+=n.nodeValue;else if(n.nodeType!==8)i+=k.getText(n.childNodes)}return i};(function(){var g=t.createElement("div"),
i="script"+(new Date).getTime(),n=t.documentElement;g.innerHTML="<a name='"+i+"'/>";n.insertBefore(g,n.firstChild);if(t.getElementById(i)){o.find.ID=function(m,p,q){if(typeof p.getElementById!=="undefined"&&!q)return(p=p.getElementById(m[1]))?p.id===m[1]||typeof p.getAttributeNode!=="undefined"&&p.getAttributeNode("id").nodeValue===m[1]?[p]:B:[]};o.filter.ID=function(m,p){var q=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&q&&q.nodeValue===p}}n.removeChild(g);
n=g=null})();(function(){var g=t.createElement("div");g.appendChild(t.createComment(""));if(g.getElementsByTagName("*").length>0)o.find.TAG=function(i,n){var m=n.getElementsByTagName(i[1]);if(i[1]==="*"){for(var p=[],q=0;m[q];q++)m[q].nodeType===1&&p.push(m[q]);m=p}return m};g.innerHTML="<a href='#'></a>";if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")o.attrHandle.href=function(i){return i.getAttribute("href",2)};g=null})();t.querySelectorAll&&
function(){var g=k,i=t.createElement("div");i.innerHTML="<p class='TEST'></p>";if(!(i.querySelectorAll&&i.querySelectorAll(".TEST").length===0)){k=function(m,p,q,u){p=p||t;m=m.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!u&&!k.isXML(p))if(p.nodeType===9)try{return C(p.querySelectorAll(m),q)}catch(y){}else if(p.nodeType===1&&p.nodeName.toLowerCase()!=="object"){var F=p.getAttribute("id"),M=F||"__sizzle__";F||p.setAttribute("id",M);try{return C(p.querySelectorAll("#"+M+" "+m),q)}catch(N){}finally{F||
p.removeAttribute("id")}}return g(m,p,q,u)};for(var n in g)k[n]=g[n];i=null}}();(function(){var g=t.documentElement,i=g.matchesSelector||g.mozMatchesSelector||g.webkitMatchesSelector||g.msMatchesSelector,n=false;try{i.call(t.documentElement,"[test!='']:sizzle")}catch(m){n=true}if(i)k.matchesSelector=function(p,q){q=q.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(p))try{if(n||!o.match.PSEUDO.test(q)&&!/!=/.test(q))return i.call(p,q)}catch(u){}return k(q,null,null,[p]).length>0}})();(function(){var g=
t.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){o.order.splice(1,0,"CLASS");o.find.CLASS=function(i,n,m){if(typeof n.getElementsByClassName!=="undefined"&&!m)return n.getElementsByClassName(i[1])};g=null}}})();k.contains=t.documentElement.contains?function(g,i){return g!==i&&(g.contains?g.contains(i):true)}:t.documentElement.compareDocumentPosition?
function(g,i){return!!(g.compareDocumentPosition(i)&16)}:function(){return false};k.isXML=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false};var L=function(g,i){for(var n,m=[],p="",q=i.nodeType?[i]:i;n=o.match.PSEUDO.exec(g);){p+=n[0];g=g.replace(o.match.PSEUDO,"")}g=o.relative[g]?g+"*":g;n=0;for(var u=q.length;n<u;n++)k(g,q[n],m);return k.filter(p,m)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=k.getText;c.isXMLDoc=k.isXML;
c.contains=k.contains})();var Za=/Until$/,$a=/^(?:parents|prevUntil|prevAll)/,ab=/,/,Na=/^.[^:#\[\.,]*$/,bb=Array.prototype.slice,cb=c.expr.match.POS;c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,e=0,f=this.length;e<f;e++){d=b.length;c.find(a,this[e],b);if(e>0)for(var h=d;h<b.length;h++)for(var l=0;l<d;l++)if(b[l]===b[h]){b.splice(h--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,e=b.length;d<e;d++)if(c.contains(this,b[d]))return true})},
not:function(a){return this.pushStack(ma(this,a,false),"not",a)},filter:function(a){return this.pushStack(ma(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){var d=[],e,f,h=this[0];if(c.isArray(a)){var l,k={},o=1;if(h&&a.length){e=0;for(f=a.length;e<f;e++){l=a[e];k[l]||(k[l]=c.expr.match.POS.test(l)?c(l,b||this.context):l)}for(;h&&h.ownerDocument&&h!==b;){for(l in k){e=k[l];if(e.jquery?e.index(h)>-1:c(h).is(e))d.push({selector:l,elem:h,level:o})}h=
h.parentNode;o++}}return d}l=cb.test(a)?c(a,b||this.context):null;e=0;for(f=this.length;e<f;e++)for(h=this[e];h;)if(l?l.index(h)>-1:c.find.matchesSelector(h,a)){d.push(h);break}else{h=h.parentNode;if(!h||!h.ownerDocument||h===b)break}d=d.length>1?c.unique(d):d;return this.pushStack(d,"closest",a)},index:function(a){if(!a||typeof a==="string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var d=typeof a==="string"?c(a,b||this.context):
c.makeArray(a),e=c.merge(this.get(),d);return this.pushStack(!d[0]||!d[0].parentNode||d[0].parentNode.nodeType===11||!e[0]||!e[0].parentNode||e[0].parentNode.nodeType===11?e:c.unique(e))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,
2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,
b){c.fn[a]=function(d,e){var f=c.map(this,b,d);Za.test(a)||(e=d);if(e&&typeof e==="string")f=c.filter(e,f);f=this.length>1?c.unique(f):f;if((this.length>1||ab.test(e))&&$a.test(a))f=f.reverse();return this.pushStack(f,a,bb.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return b.length===1?c.find.matchesSelector(b[0],a)?[b[0]]:[]:c.find.matches(a,b)},dir:function(a,b,d){var e=[];for(a=a[b];a&&a.nodeType!==9&&(d===B||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&
e.push(a);a=a[b]}return e},nth:function(a,b,d){b=b||1;for(var e=0;a;a=a[d])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var za=/ jQuery\d+="(?:\d+|null)"/g,$=/^\s+/,Aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Ba=/<([\w:]+)/,db=/<tbody/i,eb=/<|&#?\w+;/,Ca=/<(?:script|object|embed|option|style)/i,Da=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/\=([^="'>\s]+\/)>/g,P={option:[1,
"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};P.optgroup=P.option;P.tbody=P.tfoot=P.colgroup=P.caption=P.thead;P.th=P.td;if(!c.support.htmlSerialize)P._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==B)return this.empty().append((this[0]&&this[0].ownerDocument||t).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,e;(e=this[d])!=null;d++)if(!a||c.filter(a,[e]).length){if(!b&&e.nodeType===1){c.cleanData(e.getElementsByTagName("*"));c.cleanData([e])}e.parentNode&&e.parentNode.removeChild(e)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,e=this.ownerDocument;if(!d){d=e.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(za,"").replace(fb,'="$1">').replace($,"")],e)[0]}else return this.cloneNode(true)});if(a===true){na(this,b);na(this.find("*"),b.find("*"))}return b},html:function(a){if(a===B)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(za,""):null;
else if(typeof a==="string"&&!Ca.test(a)&&(c.support.leadingWhitespace||!$.test(a))&&!P[(Ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Aa,"<$1></$2>");try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(e){this.empty().append(a)}}else c.isFunction(a)?this.each(function(f){var h=c(this);h.html(a.call(this,f,h.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=
c(this),e=d.html();d.replaceWith(a.call(this,b,e))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){var e,f,h,l=a[0],k=[];if(!c.support.checkClone&&arguments.length===3&&typeof l==="string"&&Da.test(l))return this.each(function(){c(this).domManip(a,
b,d,true)});if(c.isFunction(l))return this.each(function(x){var r=c(this);a[0]=l.call(this,x,b?r.html():B);r.domManip(a,b,d)});if(this[0]){e=l&&l.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:c.buildFragment(a,this,k);h=e.fragment;if(f=h.childNodes.length===1?h=h.firstChild:h.firstChild){b=b&&c.nodeName(f,"tr");f=0;for(var o=this.length;f<o;f++)d.call(b?c.nodeName(this[f],"table")?this[f].getElementsByTagName("tbody")[0]||this[f].appendChild(this[f].ownerDocument.createElement("tbody")):
this[f]:this[f],f>0||e.cacheable||this.length>1?h.cloneNode(true):h)}k.length&&c.each(k,Oa)}return this}});c.buildFragment=function(a,b,d){var e,f,h;b=b&&b[0]?b[0].ownerDocument||b[0]:t;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===t&&!Ca.test(a[0])&&(c.support.checkClone||!Da.test(a[0]))){f=true;if(h=c.fragments[a[0]])if(h!==1)e=h}if(!e){e=b.createDocumentFragment();c.clean(a,b,e,d)}if(f)c.fragments[a[0]]=h?e:1;return{fragment:e,cacheable:f}};c.fragments={};c.each({appendTo:"append",
prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var e=[];d=c(d);var f=this.length===1&&this[0].parentNode;if(f&&f.nodeType===11&&f.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{f=0;for(var h=d.length;f<h;f++){var l=(f>0?this.clone(true):this).get();c(d[f])[b](l);e=e.concat(l)}return this.pushStack(e,a,d.selector)}}});c.extend({clean:function(a,b,d,e){b=b||t;if(typeof b.createElement==="undefined")b=b.ownerDocument||
b[0]&&b[0].ownerDocument||t;for(var f=[],h=0,l;(l=a[h])!=null;h++){if(typeof l==="number")l+="";if(l){if(typeof l==="string"&&!eb.test(l))l=b.createTextNode(l);else if(typeof l==="string"){l=l.replace(Aa,"<$1></$2>");var k=(Ba.exec(l)||["",""])[1].toLowerCase(),o=P[k]||P._default,x=o[0],r=b.createElement("div");for(r.innerHTML=o[1]+l+o[2];x--;)r=r.lastChild;if(!c.support.tbody){x=db.test(l);k=k==="table"&&!x?r.firstChild&&r.firstChild.childNodes:o[1]==="<table>"&&!x?r.childNodes:[];for(o=k.length-
1;o>=0;--o)c.nodeName(k[o],"tbody")&&!k[o].childNodes.length&&k[o].parentNode.removeChild(k[o])}!c.support.leadingWhitespace&&$.test(l)&&r.insertBefore(b.createTextNode($.exec(l)[0]),r.firstChild);l=r.childNodes}if(l.nodeType)f.push(l);else f=c.merge(f,l)}}if(d)for(h=0;f[h];h++)if(e&&c.nodeName(f[h],"script")&&(!f[h].type||f[h].type.toLowerCase()==="text/javascript"))e.push(f[h].parentNode?f[h].parentNode.removeChild(f[h]):f[h]);else{f[h].nodeType===1&&f.splice.apply(f,[h+1,0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
d.appendChild(f[h])}return f},cleanData:function(a){for(var b,d,e=c.cache,f=c.event.special,h=c.support.deleteExpando,l=0,k;(k=a[l])!=null;l++)if(!(k.nodeName&&c.noData[k.nodeName.toLowerCase()]))if(d=k[c.expando]){if((b=e[d])&&b.events)for(var o in b.events)f[o]?c.event.remove(k,o):c.removeEvent(k,o,b.handle);if(h)delete k[c.expando];else k.removeAttribute&&k.removeAttribute(c.expando);delete e[d]}}});var Ea=/alpha\([^)]*\)/i,gb=/opacity=([^)]*)/,hb=/-([a-z])/ig,ib=/([A-Z])/g,Fa=/^-?\d+(?:px)?$/i,
jb=/^-?\d/,kb={position:"absolute",visibility:"hidden",display:"block"},Pa=["Left","Right"],Qa=["Top","Bottom"],W,Ga,aa,lb=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){if(arguments.length===2&&b===B)return this;return c.access(this,a,b,true,function(d,e,f){return f!==B?c.style(d,e,f):c.css(d,e)})};c.extend({cssHooks:{opacity:{get:function(a,b){if(b){var d=W(a,"opacity","opacity");return d===""?"1":d}else return a.style.opacity}}},cssNumber:{zIndex:true,fontWeight:true,opacity:true,
zoom:true,lineHeight:true},cssProps:{"float":c.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,d,e){if(!(!a||a.nodeType===3||a.nodeType===8||!a.style)){var f,h=c.camelCase(b),l=a.style,k=c.cssHooks[h];b=c.cssProps[h]||h;if(d!==B){if(!(typeof d==="number"&&isNaN(d)||d==null)){if(typeof d==="number"&&!c.cssNumber[h])d+="px";if(!k||!("set"in k)||(d=k.set(a,d))!==B)try{l[b]=d}catch(o){}}}else{if(k&&"get"in k&&(f=k.get(a,false,e))!==B)return f;return l[b]}}},css:function(a,b,d){var e,f=c.camelCase(b),
h=c.cssHooks[f];b=c.cssProps[f]||f;if(h&&"get"in h&&(e=h.get(a,true,d))!==B)return e;else if(W)return W(a,b,f)},swap:function(a,b,d){var e={},f;for(f in b){e[f]=a.style[f];a.style[f]=b[f]}d.call(a);for(f in b)a.style[f]=e[f]},camelCase:function(a){return a.replace(hb,lb)}});c.curCSS=c.css;c.each(["height","width"],function(a,b){c.cssHooks[b]={get:function(d,e,f){var h;if(e){if(d.offsetWidth!==0)h=oa(d,b,f);else c.swap(d,kb,function(){h=oa(d,b,f)});if(h<=0){h=W(d,b,b);if(h==="0px"&&aa)h=aa(d,b,b);
if(h!=null)return h===""||h==="auto"?"0px":h}if(h<0||h==null){h=d.style[b];return h===""||h==="auto"?"0px":h}return typeof h==="string"?h:h+"px"}},set:function(d,e){if(Fa.test(e)){e=parseFloat(e);if(e>=0)return e+"px"}else return e}}});if(!c.support.opacity)c.cssHooks.opacity={get:function(a,b){return gb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var d=a.style;d.zoom=1;var e=c.isNaN(b)?"":"alpha(opacity="+b*100+")",f=
d.filter||"";d.filter=Ea.test(f)?f.replace(Ea,e):d.filter+" "+e}};if(t.defaultView&&t.defaultView.getComputedStyle)Ga=function(a,b,d){var e;d=d.replace(ib,"-$1").toLowerCase();if(!(b=a.ownerDocument.defaultView))return B;if(b=b.getComputedStyle(a,null)){e=b.getPropertyValue(d);if(e===""&&!c.contains(a.ownerDocument.documentElement,a))e=c.style(a,d)}return e};if(t.documentElement.currentStyle)aa=function(a,b){var d,e,f=a.currentStyle&&a.currentStyle[b],h=a.style;if(!Fa.test(f)&&jb.test(f)){d=h.left;
e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;h.left=b==="fontSize"?"1em":f||0;f=h.pixelLeft+"px";h.left=d;a.runtimeStyle.left=e}return f===""?"auto":f};W=Ga||aa;if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetHeight;return a.offsetWidth===0&&b===0||!c.support.reliableHiddenOffsets&&(a.style.display||c.css(a,"display"))==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var mb=c.now(),nb=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
ob=/^(?:select|textarea)/i,pb=/^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,qb=/^(?:GET|HEAD)$/,Ra=/\[\]$/,T=/\=\?(&|$)/,ja=/\?/,rb=/([?&])_=[^&]*/,sb=/^(\w+:)?\/\/([^\/?#]+)/,tb=/%20/g,ub=/#.*$/,Ha=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!=="string"&&Ha)return Ha.apply(this,arguments);else if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var f=a.slice(e,a.length);a=a.slice(0,e)}e="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===
"object"){b=c.param(b,c.ajaxSettings.traditional);e="POST"}var h=this;c.ajax({url:a,type:e,dataType:"html",data:b,complete:function(l,k){if(k==="success"||k==="notmodified")h.html(f?c("<div>").append(l.responseText.replace(nb,"")).find(f):l.responseText);d&&h.each(d,[l.responseText,k,l])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&
!this.disabled&&(this.checked||ob.test(this.nodeName)||pb.test(this.type))}).map(function(a,b){var d=c(this).val();return d==null?null:c.isArray(d)?c.map(d,function(e){return{name:b.name,value:e}}):{name:b.name,value:d}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:e})},
getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:e})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return new E.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",
script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},ajax:function(a){var b=c.extend(true,{},c.ajaxSettings,a),d,e,f,h=b.type.toUpperCase(),l=qb.test(h);b.url=b.url.replace(ub,"");b.context=a&&a.context!=null?a.context:b;if(b.data&&b.processData&&typeof b.data!=="string")b.data=c.param(b.data,b.traditional);if(b.dataType==="jsonp"){if(h==="GET")T.test(b.url)||(b.url+=(ja.test(b.url)?"&":"?")+(b.jsonp||"callback")+"=?");else if(!b.data||
!T.test(b.data))b.data=(b.data?b.data+"&":"")+(b.jsonp||"callback")+"=?";b.dataType="json"}if(b.dataType==="json"&&(b.data&&T.test(b.data)||T.test(b.url))){d=b.jsonpCallback||"jsonp"+mb++;if(b.data)b.data=(b.data+"").replace(T,"="+d+"$1");b.url=b.url.replace(T,"="+d+"$1");b.dataType="script";var k=E[d];E[d]=function(m){if(c.isFunction(k))k(m);else{E[d]=B;try{delete E[d]}catch(p){}}f=m;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);r&&r.removeChild(A)}}if(b.dataType==="script"&&b.cache===null)b.cache=
false;if(b.cache===false&&l){var o=c.now(),x=b.url.replace(rb,"$1_="+o);b.url=x+(x===b.url?(ja.test(b.url)?"&":"?")+"_="+o:"")}if(b.data&&l)b.url+=(ja.test(b.url)?"&":"?")+b.data;b.global&&c.active++===0&&c.event.trigger("ajaxStart");o=(o=sb.exec(b.url))&&(o[1]&&o[1].toLowerCase()!==location.protocol||o[2].toLowerCase()!==location.host);if(b.dataType==="script"&&h==="GET"&&o){var r=t.getElementsByTagName("head")[0]||t.documentElement,A=t.createElement("script");if(b.scriptCharset)A.charset=b.scriptCharset;
A.src=b.url;if(!d){var C=false;A.onload=A.onreadystatechange=function(){if(!C&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){C=true;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);A.onload=A.onreadystatechange=null;r&&A.parentNode&&r.removeChild(A)}}}r.insertBefore(A,r.firstChild);return B}var J=false,w=b.xhr();if(w){b.username?w.open(h,b.url,b.async,b.username,b.password):w.open(h,b.url,b.async);try{if(b.data!=null&&!l||a&&a.contentType)w.setRequestHeader("Content-Type",
b.contentType);if(b.ifModified){c.lastModified[b.url]&&w.setRequestHeader("If-Modified-Since",c.lastModified[b.url]);c.etag[b.url]&&w.setRequestHeader("If-None-Match",c.etag[b.url])}o||w.setRequestHeader("X-Requested-With","XMLHttpRequest");w.setRequestHeader("Accept",b.dataType&&b.accepts[b.dataType]?b.accepts[b.dataType]+", */*; q=0.01":b.accepts._default)}catch(I){}if(b.beforeSend&&b.beforeSend.call(b.context,w,b)===false){b.global&&c.active--===1&&c.event.trigger("ajaxStop");w.abort();return false}b.global&&
c.triggerGlobal(b,"ajaxSend",[w,b]);var L=w.onreadystatechange=function(m){if(!w||w.readyState===0||m==="abort"){J||c.handleComplete(b,w,e,f);J=true;if(w)w.onreadystatechange=c.noop}else if(!J&&w&&(w.readyState===4||m==="timeout")){J=true;w.onreadystatechange=c.noop;e=m==="timeout"?"timeout":!c.httpSuccess(w)?"error":b.ifModified&&c.httpNotModified(w,b.url)?"notmodified":"success";var p;if(e==="success")try{f=c.httpData(w,b.dataType,b)}catch(q){e="parsererror";p=q}if(e==="success"||e==="notmodified")d||
c.handleSuccess(b,w,e,f);else c.handleError(b,w,e,p);d||c.handleComplete(b,w,e,f);m==="timeout"&&w.abort();if(b.async)w=null}};try{var g=w.abort;w.abort=function(){w&&Function.prototype.call.call(g,w);L("abort")}}catch(i){}b.async&&b.timeout>0&&setTimeout(function(){w&&!J&&L("timeout")},b.timeout);try{w.send(l||b.data==null?null:b.data)}catch(n){c.handleError(b,w,null,n);c.handleComplete(b,w,e,f)}b.async||L();return w}},param:function(a,b){var d=[],e=function(h,l){l=c.isFunction(l)?l():l;d[d.length]=
encodeURIComponent(h)+"="+encodeURIComponent(l)};if(b===B)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){e(this.name,this.value)});else for(var f in a)da(f,a[f],b,e);return d.join("&").replace(tb,"+")}});c.extend({active:0,lastModified:{},etag:{},handleError:function(a,b,d,e){a.error&&a.error.call(a.context,b,d,e);a.global&&c.triggerGlobal(a,"ajaxError",[b,a,e])},handleSuccess:function(a,b,d,e){a.success&&a.success.call(a.context,e,d,b);a.global&&c.triggerGlobal(a,"ajaxSuccess",
[b,a])},handleComplete:function(a,b,d){a.complete&&a.complete.call(a.context,b,d);a.global&&c.triggerGlobal(a,"ajaxComplete",[b,a]);a.global&&c.active--===1&&c.event.trigger("ajaxStop")},triggerGlobal:function(a,b,d){(a.context&&a.context.url==null?c(a.context):c.event).trigger(b,d)},httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===1223}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),
e=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(e)c.etag[b]=e;return a.status===304},httpData:function(a,b,d){var e=a.getResponseHeader("content-type")||"",f=b==="xml"||!b&&e.indexOf("xml")>=0;a=f?a.responseXML:a.responseText;f&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b==="json"||!b&&e.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&e.indexOf("javascript")>=0)c.globalEval(a);return a}});
if(E.ActiveXObject)c.ajaxSettings.xhr=function(){if(E.location.protocol!=="file:")try{return new E.XMLHttpRequest}catch(a){}try{return new E.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}};c.support.ajax=!!c.ajaxSettings.xhr();var ea={},vb=/^(?:toggle|show|hide)$/,wb=/^([+\-]=)?([\d+.\-]+)(.*)$/,ba,pa=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b,d){if(a||a===0)return this.animate(S("show",
3),a,b,d);else{d=0;for(var e=this.length;d<e;d++){a=this[d];b=a.style.display;if(!c.data(a,"olddisplay")&&b==="none")b=a.style.display="";b===""&&c.css(a,"display")==="none"&&c.data(a,"olddisplay",qa(a.nodeName))}for(d=0;d<e;d++){a=this[d];b=a.style.display;if(b===""||b==="none")a.style.display=c.data(a,"olddisplay")||""}return this}},hide:function(a,b,d){if(a||a===0)return this.animate(S("hide",3),a,b,d);else{a=0;for(b=this.length;a<b;a++){d=c.css(this[a],"display");d!=="none"&&c.data(this[a],"olddisplay",
d)}for(a=0;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b,d){var e=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||e?this.each(function(){var f=e?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(S("toggle",3),a,b,d);return this},fadeTo:function(a,b,d,e){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d,e)},animate:function(a,b,d,e){var f=c.speed(b,
d,e);if(c.isEmptyObject(a))return this.each(f.complete);return this[f.queue===false?"each":"queue"](function(){var h=c.extend({},f),l,k=this.nodeType===1,o=k&&c(this).is(":hidden"),x=this;for(l in a){var r=c.camelCase(l);if(l!==r){a[r]=a[l];delete a[l];l=r}if(a[l]==="hide"&&o||a[l]==="show"&&!o)return h.complete.call(this);if(k&&(l==="height"||l==="width")){h.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY];if(c.css(this,"display")==="inline"&&c.css(this,"float")==="none")if(c.support.inlineBlockNeedsLayout)if(qa(this.nodeName)===
"inline")this.style.display="inline-block";else{this.style.display="inline";this.style.zoom=1}else this.style.display="inline-block"}if(c.isArray(a[l])){(h.specialEasing=h.specialEasing||{})[l]=a[l][1];a[l]=a[l][0]}}if(h.overflow!=null)this.style.overflow="hidden";h.curAnim=c.extend({},a);c.each(a,function(A,C){var J=new c.fx(x,h,A);if(vb.test(C))J[C==="toggle"?o?"show":"hide":C](a);else{var w=wb.exec(C),I=J.cur()||0;if(w){var L=parseFloat(w[2]),g=w[3]||"px";if(g!=="px"){c.style(x,A,(L||1)+g);I=(L||
1)/J.cur()*I;c.style(x,A,I+g)}if(w[1])L=(w[1]==="-="?-1:1)*L+I;J.custom(I,L,g)}else J.custom(I,C,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var e=d.length-1;e>=0;e--)if(d[e].elem===this){b&&d[e](true);d.splice(e,1)}});b||this.dequeue();return this}});c.each({slideDown:S("show",1),slideUp:S("hide",1),slideToggle:S("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){c.fn[a]=function(d,e,f){return this.animate(b,
d,e,f)}});c.extend({speed:function(a,b,d){var e=a&&typeof a==="object"?c.extend({},a):{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};e.duration=c.fx.off?0:typeof e.duration==="number"?e.duration:e.duration in c.fx.speeds?c.fx.speeds[e.duration]:c.fx.speeds._default;e.old=e.complete;e.complete=function(){e.queue!==false&&c(this).dequeue();c.isFunction(e.old)&&e.old.call(this)};return e},easing:{linear:function(a,b,d,e){return d+e*a},swing:function(a,b,d,e){return(-Math.cos(a*
Math.PI)/2+0.5)*e+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a=parseFloat(c.css(this.elem,this.prop));return a&&a>-1E4?a:0},custom:function(a,b,d){function e(l){return f.step(l)}
var f=this,h=c.fx;this.startTime=c.now();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;this.pos=this.state=0;e.elem=this.elem;if(e()&&c.timers.push(e)&&!ba)ba=setInterval(h.tick,h.interval)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;
this.custom(this.cur(),0)},step:function(a){var b=c.now(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var e in this.options.curAnim)if(this.options.curAnim[e]!==true)d=false;if(d){if(this.options.overflow!=null&&!c.support.shrinkWrapBlocks){var f=this.elem,h=this.options;c.each(["","X","Y"],function(k,o){f.style["overflow"+o]=h.overflow[k]})}this.options.hide&&c(this.elem).hide();if(this.options.hide||
this.options.show)for(var l in this.options.curAnim)c.style(this.elem,l,this.options.orig[l]);this.options.complete.call(this.elem)}return false}else{a=b-this.startTime;this.state=a/this.options.duration;b=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||b](this.state,a,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=
c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},interval:13,stop:function(){clearInterval(ba);ba=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===
b.elem}).length};var xb=/^t(?:able|d|h)$/i,Ia=/^(?:body|html)$/i;c.fn.offset="getBoundingClientRect"in t.documentElement?function(a){var b=this[0],d;if(a)return this.each(function(l){c.offset.setOffset(this,a,l)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);try{d=b.getBoundingClientRect()}catch(e){}var f=b.ownerDocument,h=f.documentElement;if(!d||!c.contains(h,b))return d||{top:0,left:0};b=f.body;f=fa(f);return{top:d.top+(f.pageYOffset||c.support.boxModel&&
h.scrollTop||b.scrollTop)-(h.clientTop||b.clientTop||0),left:d.left+(f.pageXOffset||c.support.boxModel&&h.scrollLeft||b.scrollLeft)-(h.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(x){c.offset.setOffset(this,a,x)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d,e=b.offsetParent,f=b.ownerDocument,h=f.documentElement,l=f.body;d=(f=f.defaultView)?f.getComputedStyle(b,null):b.currentStyle;
for(var k=b.offsetTop,o=b.offsetLeft;(b=b.parentNode)&&b!==l&&b!==h;){if(c.offset.supportsFixedPosition&&d.position==="fixed")break;d=f?f.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;o-=b.scrollLeft;if(b===e){k+=b.offsetTop;o+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&xb.test(b.nodeName))){k+=parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}e=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"){k+=
parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}d=d}if(d.position==="relative"||d.position==="static"){k+=l.offsetTop;o+=l.offsetLeft}if(c.offset.supportsFixedPosition&&d.position==="fixed"){k+=Math.max(h.scrollTop,l.scrollTop);o+=Math.max(h.scrollLeft,l.scrollLeft)}return{top:k,left:o}};c.offset={initialize:function(){var a=t.body,b=t.createElement("div"),d,e,f,h=parseFloat(c.css(a,"marginTop"))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",
height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";a.insertBefore(b,a.firstChild);d=b.firstChild;e=d.firstChild;f=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=e.offsetTop!==5;this.doesAddBorderForTableAndCells=
f.offsetTop===5;e.style.position="fixed";e.style.top="20px";this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15;e.style.position=e.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==h;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.css(a,
"marginTop"))||0;d+=parseFloat(c.css(a,"marginLeft"))||0}return{top:b,left:d}},setOffset:function(a,b,d){var e=c.css(a,"position");if(e==="static")a.style.position="relative";var f=c(a),h=f.offset(),l=c.css(a,"top"),k=c.css(a,"left"),o=e==="absolute"&&c.inArray("auto",[l,k])>-1;e={};var x={};if(o)x=f.position();l=o?x.top:parseInt(l,10)||0;k=o?x.left:parseInt(k,10)||0;if(c.isFunction(b))b=b.call(a,d,h);if(b.top!=null)e.top=b.top-h.top+l;if(b.left!=null)e.left=b.left-h.left+k;"using"in b?b.using.call(a,
e):f.css(e)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),e=Ia.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.css(a,"marginTop"))||0;d.left-=parseFloat(c.css(a,"marginLeft"))||0;e.top+=parseFloat(c.css(b[0],"borderTopWidth"))||0;e.left+=parseFloat(c.css(b[0],"borderLeftWidth"))||0;return{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||t.body;a&&!Ia.test(a.nodeName)&&
c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(e){var f=this[0],h;if(!f)return null;if(e!==B)return this.each(function(){if(h=fa(this))h.scrollTo(!a?e:c(h).scrollLeft(),a?e:c(h).scrollTop());else this[d]=e});else return(h=fa(f))?"pageXOffset"in h?h[a?"pageYOffset":"pageXOffset"]:c.support.boxModel&&h.document.documentElement[d]||h.document.body[d]:f[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();
c.fn["inner"+b]=function(){return this[0]?parseFloat(c.css(this[0],d,"padding")):null};c.fn["outer"+b]=function(e){return this[0]?parseFloat(c.css(this[0],d,e?"margin":"border")):null};c.fn[d]=function(e){var f=this[0];if(!f)return e==null?null:this;if(c.isFunction(e))return this.each(function(l){var k=c(this);k[d](e.call(this,l,k[d]()))});if(c.isWindow(f))return f.document.compatMode==="CSS1Compat"&&f.document.documentElement["client"+b]||f.document.body["client"+b];else if(f.nodeType===9)return Math.max(f.documentElement["client"+
b],f.body["scroll"+b],f.documentElement["scroll"+b],f.body["offset"+b],f.documentElement["offset"+b]);else if(e===B){f=c.css(f,d);var h=parseFloat(f);return c.isNaN(h)?f:h}else return this.css(d,typeof e==="string"?e:e+"px")}})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>distillery -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">distillery</h1><h2 class="project-version">0.4.0</h2><br /><p>A Clojure application to filter the most relevant words from speech recognition results.</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.5.1</td></tr><tr><td class="dep-name">org.clojure/data.xml</td><td class="dotted"><hr /></td><td class="dep-version">0.0.7</td></tr><tr><td class="dep-name">enlive</td><td class="dotted"><hr /></td><td class="dep-version">1.1.1</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#distillery.blacklist">distillery.blacklist</a></li><li><a href="#distillery.config">distillery.config</a></li><li><a href="#distillery.core">distillery.core</a></li><li><a href="#distillery.data">distillery.data</a></li><li><a href="#distillery.processing">distillery.processing</a></li><li><a href="#distillery.tasks">distillery.tasks</a></li><li><a href="#distillery.text">distillery.text</a></li><li><a href="#distillery.txtresult">distillery.txtresult</a></li><li><a href="#distillery.view.base">distillery.view.base</a></li><li><a href="#distillery.view.category">distillery.view.category</a></li><li><a href="#distillery.view.cloud">distillery.view.cloud</a></li><li><a href="#distillery.view.defaults">distillery.view.defaults</a></li><li><a href="#distillery.view.dependencies">distillery.view.dependencies</a></li><li><a href="#distillery.view.glossary">distillery.view.glossary</a></li><li><a href="#distillery.view.hitlist">distillery.view.hitlist</a></li><li><a href="#distillery.view.html">distillery.view.html</a></li><li><a href="#distillery.view.index">distillery.view.index</a></li><li><a href="#distillery.view.match">distillery.view.match</a></li><li><a href="#distillery.view.medium">distillery.view.medium</a></li><li><a href="#distillery.view.transcript">distillery.view.transcript</a></li><li><a href="#distillery.view.word">distillery.view.word</a></li><li><a href="#distillery.xmlresult">distillery.xmlresult</a></li><li><a href="#mastersign.drawing">mastersign.drawing</a></li><li><a href="#mastersign.files">mastersign.files</a></li><li><a href="#mastersign.geom">mastersign.geom</a></li><li><a href="#mastersign.html">mastersign.html</a></li><li><a href="#mastersign.imaging">mastersign.imaging</a></li><li><a href="#mastersign.trace">mastersign.trace</a></li><li><a href="#mastersign.wordcloud">mastersign.wordcloud</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.blacklist" name="distillery.blacklist"><h1 class="project-name">distillery.blacklist</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Blacklist</h1>

<p>This namespace contains functions for using the blacklist
to filter words.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.blacklist
  (:require [clojure.java.io :refer (resource)])
  (:require [distillery.config :as cfg])
  (:require [distillery.data :refer :all])
  (:require [distillery.processing :refer (word-text)]))</pre></td></tr><tr><td class="docs"><p>This private var holds a reference to a set with all words of the blacklist.
The words are loaded automatically into the var during application startup.
The resource file with the words is specified by the application configuration.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:private blacklist
  (-&gt;&gt; (cfg/value :blacklist-resource)
       resource
       load-list
       (take (cfg/value :blacklist-max-size))
       (map #(.toLowerCase ^String %))
       set))</pre></td></tr><tr><td class="docs"><p>This function is a predicate, checking if <code>word</code> is not in the blacklist.
  The word can be a string or a map with a the key <code>:lexical-form.</code></p>
</td><td class="codes"><pre class="brush: clojure">(defn not-in-blacklist?
  [word]
  (let [text (.toLowerCase ^String (word-text word))]
    (not (contains? blacklist text))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.config" name="distillery.config"><h1 class="project-name">distillery.config</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Application Configuration</h1>

<p>The application configuration is a map with parameters
controlling the analysis and result generation process.
The application configuration is build by merging the
default configuration from <code>resources/default.cfg</code>
with the <a href="data-structures.html#Configuration">Configuration</a>
in the <a href="data-structures.html#JobDescription">Job Description</a>.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.config
  (:require [clojure.java.io :refer (resource)])
  (:require [distillery.data :refer (load-data)]))</pre></td></tr><tr><td class="docs"><p>A public var with a the default configuration.</p>
</td><td class="codes"><pre class="brush: clojure">(def default (load-data (resource &quot;default-config.edn&quot;)))</pre></td></tr><tr><td class="docs"><p>Retrieves the value of a configuration parameter by its key.</p>

<p>  The first argument <code>k</code> is the key of the parameter,
  the optional second argument <code>cfg</code> is the job configuration
  overlaying the default configuration.</p>
</td><td class="codes"><pre class="brush: clojure">(defn value
  ([k]
   (let [ks (if (coll? k) (vec k) [k])]
     (get-in default ks)))
  ([k cfg]
   (let [ks (if (coll? k) (vec k) [k])]
     (get-in cfg ks (get-in default ks nil)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.core" name="distillery.core"><h1 class="project-name">distillery.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Application Core</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.core
  (:require [clojure.pprint :refer (pprint)])
  (:require [mastersign.trace :refer :all])
  (:require [distillery.data :refer :all])
  (:require [distillery.tasks :as dt])
  (:gen-class))</pre></td></tr><tr><td class="docs"><h2>Core Tasks</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>The following functions represent the most coarse processing steps
in this application. The main data structures in this context are the
<a href="data-structures.html#JobDescription">Job Description</a>
and the <a href="data-structures.html#AnalysisResults">Analysis Results</a>.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Takes a job description, loads all referenced data,
  and matches the speech recognition results against the category resources.
  Returns an extended version of the job description with the loaded
  data and the matching results attached.</p>
</td><td class="codes"><pre class="brush: clojure">(defn prepare-and-analyze
  [job-descr]
  (dt/process-pipeline
   &quot;Analysis&quot;
   job-descr
   dt/load-speech-recognition-results
   dt/analyze-speech-recognition-results
   dt/load-categories
   dt/analyze-categories
   dt/match-media
   dt/lookup-categories-matches
   dt/matching-stats))</pre></td></tr><tr><td class="docs"><p>Takes an extended job description generated by <code>prepare-and-analyze</code>
  and generates the XML result file for the job.
  Returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn generate-xml-result-file!
  [job]
  (trace-block
   &quot;XML Result Generation&quot;
   (dt/save-result-as-xml job)))</pre></td></tr><tr><td class="docs"><p>Takes an extended job description generated by <code>prepare-and-analyze</code>
  and generates the transcript text files for the media in the job.
  Returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn generate-txt-result-files!
  [job]
  (trace-block
   &quot;Text Result Generation&quot;
   (dt/save-result-as-txt job)))</pre></td></tr><tr><td class="docs"><p>Takes an extended job description generated by <code>prepare-and-analyze</code>
  and generates a static website with extensive visualization of the result.
  Returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn generate-website!
  [job]
  (trace-block
   &quot;Result Visualization&quot;
   (dt/prepare-output-dir job)
   (dt/process-task-group
    &quot;Website Generation&quot; job #(% job)
    [dt/create-index-page
     dt/create-categories-page
     dt/create-category-pages
     dt/create-media-page
     dt/create-medium-pages]))
  nil)</pre></td></tr><tr><td class="docs"><p>Takes a job description, and executes the complete process
  defined by the job.</p>
</td><td class="codes"><pre class="brush: clojure">(defn run-complete!
  [job-descr]
  (let [job (prepare-and-analyze job-descr)]
    (generate-xml-result-file! job)
    (generate-txt-result-files! job)
    (when (get-in job [:configuration :visualize-result])
      (generate-website! job)))
  nil)</pre></td></tr><tr><td class="docs"><h2>Entry Point</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>The entry point for the application.
  Takes the path of the job file as the only argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defn -main
  [job-file]
  (-&gt; job-file
      load-data
      run-complete!)
  (System/exit 0))</pre></td></tr><tr><td class="docs"><h2>Debugging</h2>

<p>Some prepared expressions for interactive debugging</p>

<pre><code>(def job-file "D:\\Temp\\MediaCategorizerOutput\\_tmp_\\job.edn")
(def job-descr (load-data job-file))
(def job (prepare-and-analyze job-descr))
(generate-xml-result-file! job)
(generate-txt-result-files! job)
(generate-website! job)
(run-complete! job-descr)

(def job (assoc-in job [:configuration :skip-wordclouds] true))
(def job (assoc-in job [:configuration :skip-wordclouds] false))
(def job (assoc-in job [:configuration :parallel-proc] true))
(def job (assoc-in job [:configuration :parallel-proc] false))
</code></pre>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.data" name="distillery.data"><h1 class="project-name">distillery.data</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.data
  (:require [clojure.java.io :refer (reader)])
  (:require [clojure.string :as string])
  (:require [clojure.edn :as edn])
  (:require [net.cgrand.enlive-html :as eh]))</pre></td></tr><tr><td class="docs"><h2>Data Input</h2>

<p>Functions to read data from URLs or files.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h3>Private Functions</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Creates an java.io.Reader from an URL or file path.
  The sequence opts can be [:encoding "<encoding>"].
  The default encoding is UTF-8</p>
</td><td class="codes"><pre class="brush: clojure">(defn- build-reader
  [x opts]
  (apply reader (cons x opts)))</pre></td></tr><tr><td class="docs"><p>Reads all text from the given URL or file path.
  For opts see build-reader.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- read-text
  [x opts]
  (apply slurp (cons x opts)))</pre></td></tr><tr><td class="docs"><h3>Public Functions</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>All <code>load-*</code> functions do have the same interface.
The first argument is the URL or file path to the resource.
The later arguments can be flags to control the way
the resource is read.
For now, only the <code>:encoding</code> flag is supported.</p>

<p>To read all text from a resource use
<code>(load-text "myfile.txt" :encoding "ISO-LATIN-1")</code>.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Loads the content of an URL or file as EDN formatted data structure.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-data
  [x &amp; opts]
  (with-open
    [r (java.io.PushbackReader. (build-reader x opts))]
    (edn/read r)))</pre></td></tr><tr><td class="docs"><p>Loads the content from an URL or file as plain text.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-text
  [x &amp; opts]
  (read-text x opts))</pre></td></tr><tr><td class="docs"><p>Loads the content of an URL or file as word list.
  Whitespace and commas are word separators.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-list
  [x &amp; opts]
  (let [text (read-text x opts)]
    (string/split text #&quot;[\s,]+&quot;)))</pre></td></tr><tr><td class="docs"><p>Loads the textual content from an HTML page.
  The optional <code>:selector</code> argument gives an enlive selector for the HTML nodes to use.
  Example: <code>(load-text-from-html "http://my-site.com" :selector [[:section (attr= "main")]])</code></p>
</td><td class="codes"><pre class="brush: clojure">(defn load-text-from-html
  [x &amp; opts]
  (let [opts-map (apply hash-map opts)
        selector (or (:selector opts-map) #{[:head :title] [:body]})
        nodes (-&gt; (build-reader x opts)
                  (eh/html-resource)
                  (eh/select selector)
                  (eh/transform [:script] nil)
                  (eh/select [eh/text-node]))]
    (-&gt;&gt; nodes
         (map eh/text)
         (filter #(not (string/blank? %)))
         (map string/trim)
         (string/join &quot; &quot;))))</pre></td></tr><tr><td class="docs"><p>Loads the textual content from an Wikipedia page.</p>

<p>  Takes the resource directly if the given URL uses the file protocol;
  otherwise appends the query <code>?action=render</code> to the URL to get
  a stripped version of the wikipedia page.</p>

<p>  Removes a number of typical elements from the page
  which occures in most wikipedia paged.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-text-from-wikipedia
  [^String url &amp; opts]
  (let [url (if (.startsWith url &quot;file://&quot;)
              url
              (str url &quot;?action=render&quot;))
        nodes (-&gt; (build-reader url opts)
                  (eh/html-resource)
                  (eh/transform #{[:script]
                                  [:.noprint]
                                  [:.mw-editsection]
                                  [:.mw-magiclink-isbn]
                                  [:.sisterproject]
                                  [:#Siehe_auch]
                                  [:#Literatur]
                                  [:#Einzelnachweise]
                                  [:#Weblinks]
                                  [:#normdaten]} nil)
                  (eh/select [eh/text-node]))]
    (-&gt;&gt; nodes
         (map eh/text)
         (filter #(not (string/blank? %)))
         (map string/trim)
         (string/join &quot; &quot;))))</pre></td></tr><tr><td class="docs"><p>Creates a sequence of words from a plain text.</p>
</td><td class="codes"><pre class="brush: clojure">(defn words-from-text
  [text]
  (-&gt;&gt; (string/split text #&quot;\b&quot;)
       (filter #(not (string/blank? %)))
       (map string/trim)))</pre></td></tr><tr><td class="docs"><h2>Collection Processing</h2>

<p>Basic helper functions to process maps and collections.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h3>General</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns true if the predicate returns true for at least one value in coll; otherwise false.</p>
</td><td class="codes"><pre class="brush: clojure">(defn any?
  [pred coll]
  (not (empty? (filter pred coll))))</pre></td></tr><tr><td class="docs"><p>Creates a comparator, defined by a function which takes an element and returns the key.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro key-comp
  [f-key]
  `(fn [a# b#] (compare (~f-key a#) (~f-key b#))))</pre></td></tr><tr><td class="docs"><p>Applies a number of predicates to a value and returns true if all predicates are true.</p>
</td><td class="codes"><pre class="brush: clojure">(defn multi-filter
  [predicates x]
  (if (empty? predicates)
    true
    (every? true? ((apply juxt predicates) x))))</pre></td></tr><tr><td class="docs"><p>Groups a collection by a key, computed by key-fn, and reduces the values of each group with f.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reduce-by
  [key-fn f init coll]
  (reduce (fn [summaries x]
            (let [k (key-fn x)]
              (assoc summaries k (f (summaries k init) x))))
          {} coll))</pre></td></tr><tr><td class="docs"><p>Groups a collection by a key, computed by key-fn, and reduces the values of each group with f.
   Returns a sorted map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reduce-by-sorted
  [key-fn f init coll]
  (reduce (fn [summaries x]
            (let [k (key-fn x)]
              (assoc summaries k (f (summaries k init) x))))
          (sorted-map) coll))</pre></td></tr><tr><td class="docs"><h3>Maps</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Applies a function to the items of a group collection.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-group-items
  [f [k xs]] [k (map f xs)])</pre></td></tr><tr><td class="docs"><p>Applies a function to the value of a key-value-pair.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-pair-value
  [f [k v]] [k (f v)])</pre></td></tr><tr><td class="docs"><p>Applies a function to the values of a map and returns a map with associating the original keys with the transformed values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-values
  [f m]
  (apply (if (sorted? m) sorted-map hash-map) (apply concat (map #(map-pair-value f %) m))))</pre></td></tr><tr><td class="docs"><h2>Collection Math</h2>

<p>A few helper functions to simplify some mathematical tasks on collections.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Computes the maximum of a numeric sequence.
  Returns <code>0</code> if the sequence is empty.</p>
</td><td class="codes"><pre class="brush: clojure">(defn safe-max
  [xs]
  (if (empty? xs) 0 (apply max xs)))</pre></td></tr><tr><td class="docs"><p>Computes the sum of a numeric sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sum
  [xs] (apply + xs))</pre></td></tr><tr><td class="docs"><p>Computes the mean value of a numeric sequence.
  Return <code>0</code> if the sequence is empty.</p>
</td><td class="codes"><pre class="brush: clojure">(defn mean
  [xs]
  (let [cnt (count xs)]
    (if (&gt; cnt 0) (/ (apply + xs) cnt) 0)))</pre></td></tr><tr><td class="docs"><p>Computes the sum of the squared items of a sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn squared-sum
  [xs] (apply + (map #(* % %) xs)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.processing" name="distillery.processing"><h1 class="project-name">distillery.processing</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.processing
  (:require [clojure.string :as string])
  (:require [distillery.config :as cfg])
  (:require [distillery.data :refer :all]))</pre></td></tr><tr><td class="docs"><p>Annotates the result data structures with indices pointing upwards.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reverse-index-results
  [results]
  (let [t-rword (fn [word result]
                  (assoc word
                    :result-no (:no result)))
        t-pword (fn [word alt result]
                  (assoc word
                    :alt-no (:no alt)
                    :result-no (:no result)))
        t-alt (fn [alt result]
                   (assoc alt
                     :result-no (:no result)
                     :words (vec (map #(t-pword % alt result) (:words alt)))))
        t-result (fn [result]
                   (-&gt; result
                       (assoc :words (vec (map #(t-rword % result) (:words result))))
                       (assoc :alternates (vec (map #(t-alt % result) (:alternates result))))))]
    (vec (map t-result results))))</pre></td></tr><tr><td class="docs"><p>Removes potential alternate phrases from results for memory optimization.</p>
</td><td class="codes"><pre class="brush: clojure">(defn strip-alternates
  [results]
  (map #(dissoc % :alternates) results))</pre></td></tr><tr><td class="docs"><p>Returns the result which contains the given word.</p>
</td><td class="codes"><pre class="brush: clojure">(defn result-of-word
  [word results]
  (get results (:result-no word)))</pre></td></tr><tr><td class="docs"><p>Returns the phrase which contains the given word.
   The phrase can be a result.</p>
</td><td class="codes"><pre class="brush: clojure">(defn phrase-of-word
  [word results]
  (if (contains? word :alt-no)
    (get (get results (:result-no word)) (:alt-no word))
    (get results (:result-no word))))</pre></td></tr><tr><td class="docs"><p>Returns the text of a word.
  The word can be a string or a map with a the key <code>:lexical-form.</code></p>
</td><td class="codes"><pre class="brush: clojure">(defn word-text
  [word]
  (or (if (map? word) (:lexical-form word) word) &quot;&quot;))</pre></td></tr><tr><td class="docs"><p>Checks whether the given word ends with a colon.</p>
</td><td class="codes"><pre class="brush: clojure">(defn no-punctuation?
  [word]
  (let [^String text (:text word)
        regex (re-pattern &quot;\\W&quot;)]
    (not (re-find regex text))))</pre></td></tr><tr><td class="docs"><p>Checks whether a word is long enough to be relevant.</p>
</td><td class="codes"><pre class="brush: clojure">(defn not-short?
  [word]
  (let [text (word-text word)]
    (not (&lt; (count text) 3))))</pre></td></tr><tr><td class="docs"><p>Checks whether the given word is a noun.</p>
</td><td class="codes"><pre class="brush: clojure">(defn noun?
  [word]
  (let [text (word-text word)
        ^Character c (or (first text) \a)]
    (java.lang.Character/isUpperCase c)))</pre></td></tr><tr><td class="docs"><p>Checks wheter the given word was recognized with a minimum of confidence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn min-confidence?
  [word]
  (-&gt; word
      :confidence
      (&gt;= (cfg/value :min-confidence))))</pre></td></tr><tr><td class="docs"><p>Checks wheter the given word was recognized with good confidence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn good-confidence?
  [word]
  (-&gt; word
      :confidence
      (&gt;= (cfg/value :good-confidence))))</pre></td></tr><tr><td class="docs"><p>Returns alternate phrases of the recognition results.</p>
</td><td class="codes"><pre class="brush: clojure">(defn alternate-phrases
  [results]
  (mapcat :alternates results))</pre></td></tr><tr><td class="docs"><p>Returns words without statistic infos from a result sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn words
  [phrases &amp; {:keys [predicate]}]
  (let [predicate (or predicate (fn [x] true))]
    (-&gt;&gt; phrases
         (mapcat :words)
         (filter predicate))))</pre></td></tr><tr><td class="docs"><p>Returns a word with statistic infos for a grouped word.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- process-word-group
  [word-group]
  (-&gt;&gt; word-group
       (map-group-items :confidence)
       (map-pair-value (fn [xs] {:confidence (mean xs)
                                 :scs (squared-sum xs)
                                 :appearance (count xs)}))
       (apply merge)))</pre></td></tr><tr><td class="docs"><p>Returns ordered statistics over a sequence of phrases.</p>
</td><td class="codes"><pre class="brush: clojure">(defn grouped-words
  [results word-filters group-filters]
  (let [word-filter (partial multi-filter (vec word-filters))
        group-filter (partial multi-filter (vec group-filters))]
    (-&gt;&gt; (words results :predicate word-filter)
         (group-by #(dissoc % :no :result-no :alt-no :confidence))
         (map process-word-group)
         (filter group-filter))))</pre></td></tr><tr><td class="docs"><p>Returns the most frequent word from all words in the results.</p>
</td><td class="codes"><pre class="brush: clojure">(defn most-frequent-word
  [results]
  (-&gt;&gt; (words results)
       (group-by :lexical-form)
       (map (fn [[text group]] [text (count group)]))
       (apply max-key #(get % 1))))</pre></td></tr><tr><td class="docs"><p>The appearance of the most frequent word in the given words.</p>
</td><td class="codes"><pre class="brush: clojure">(defn max-appearance
  [words]
  (-&gt;&gt; words
       (map :appearance)
       (safe-max)))</pre></td></tr><tr><td class="docs"><p>Returns frequent words that are most likely false recognized.</p>
</td><td class="codes"><pre class="brush: clojure">(defn correction-candidates
  [words]
  (let [norm (max-appearance words)]
    (-&gt;&gt; words
         (map #(assoc % :relative-appearance (if (&gt; (:appearance %) 1) (/ (:appearance %) norm) 0)))
         (filter #(and
                   (&lt; (:confidence %) (cfg/value :good-confidence))
                   (&gt;= (:relative-appearance %) (cfg/value :min-relative-appearance)))))))</pre></td></tr><tr><td class="docs"><p>Creates a formatted string for the given word.</p>
</td><td class="codes"><pre class="brush: clojure">(defn format-word-stat
  [{:keys [lexical-form pronunciation appearance scs confidence]}]
  (format &quot;%4d %8.3f %5.1f %%: %s (%s)&quot;
          appearance
          scs
          (* 100 confidence)
          lexical-form
          pronunciation))</pre></td></tr><tr><td class="docs"><p>Prints a list of words.</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-word-list
  [words]
  (-&gt;&gt; words
       (map format-word-stat)
       (cons &quot;---------------------------------------------------&quot;)
       (cons &quot;#  N      SCS    CONF: Lexical Form (Pronunciation)&quot;)
       (string/join &quot;\n&quot;)
       println))</pre></td></tr><tr><td class="docs"><p>Creates an identifier for a word.
   The identifier can be used as HTML/XML ID or as filename.</p>
</td><td class="codes"><pre class="brush: clojure">(defn word-identifier
  [{:keys [^String lexical-form] :as word}]
  (comment &quot;TODO Needs to be improved for arbitrary characters!&quot;)
  (-&gt; lexical-form
      (.toLowerCase)
      (.replace &quot;ß&quot; &quot;ss&quot;)
      (.replace &quot;ä&quot; &quot;ae&quot;)
      (.replace &quot;ö&quot; &quot;oe&quot;)
      (.replace &quot;ü&quot; &quot;ue&quot;)
      (string/replace #&quot;\W&quot; &quot;_&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- compute-index-entry-stats
  [{:keys [occurrences] :as entry}]
  (assoc entry
    :occurrence-count (count occurrences)
    :mean-confidence (mean (map :confidence occurrences))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- compute-index-entry-match-value
  [{:keys [max-occurrence-count] :as index-stats}
   {:keys [mean-confidence occurrence-count] :as entry}]
  (assoc entry
    :match-value (* (double mean-confidence)
                    (/ (double occurrence-count)
                       (double max-occurrence-count)))))</pre></td></tr><tr><td class="docs"><p>Merges two index entries for the same word into one.</p>
</td><td class="codes"><pre class="brush: clojure">(defn merge-index-entries
  [a b]
  (let [res (-&gt; a
      (assoc :occurrences (concat (:occurrences a) (:occurrences b)))
      compute-index-entry-stats)]
    res))</pre></td></tr><tr><td class="docs"><p>Builds an index of words for a sequence of recognition results.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-medium-word-index
  [medium &amp; {:keys [predicate]}]
  (let [ws (words (:results medium) :predicate predicate)
        add-occurrence (fn [props word]
                         (let [props (or props {:id (:id word)
                                                :lexical-form (:lexical-form word)
                                                :pronunciation (:pronunciation word)})]
                           (assoc props :occurrences
                             (conj (:occurrences props [])
                                   {:medium-id (:id medium)
                                    :result-no (:result-no word)
                                    :word-no (:no word)
                                    :confidence (:confidence word)}))))
        index (-&gt;&gt; ws
                   (map #(assoc % :id (word-identifier %)))
                   (reduce-by-sorted :id add-occurrence nil)
                   (map-values compute-index-entry-stats))
        index-stats {:count (count index)
                     :max-occurrence-count (safe-max (map :occurrence-count (vals index)))}
        index (map-values (partial compute-index-entry-match-value index-stats) index)]
    (assoc medium
      :index index
      :index-stats index-stats)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- category-words
  [{:keys [words] :as category} &amp; {:keys [predicate]}]
  (filter predicate words))</pre></td></tr><tr><td class="docs"><p>Builds an index for a sequence of category words.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-category-word-index
  [category &amp; {:keys [predicate]}]
  (let [ws (category-words category :predicate predicate)
        add-occurrence (fn [props word]
                        (let [props (or props {:id (:id word)
                                               :lexical-form (:lexical-form word)})]
                          (assoc props :occurrences
                            (conj (:occurrences props [])
                                  {:category-id (:id category)
                                   :no (:no word)
                                   :confidence 1}))))
        index (-&gt;&gt; ws
                   (map #(assoc % :id (word-identifier %)))
                   (reduce-by-sorted :id add-occurrence nil)
                   (map-values compute-index-entry-stats))
        index-stats {:count (count index)
                     :max-occurrence-count (safe-max (map :occurrence-count (vals index)))}
        index (map-values (partial compute-index-entry-match-value index-stats) index)]
    (assoc category
      :index index
      :index-stats index-stats)))</pre></td></tr><tr><td class="docs"><p>Converts every alphabetic character in its upper case and all other characters into '?'.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- char-to-index-letter
  [^Character c]
  (let [c (java.lang.Character/toUpperCase c)
        n (int c)]
    (if (and (&gt;= n 65) (&lt;= n 91)) c \?)))</pre></td></tr><tr><td class="docs"><p>Partitions an index into sections.
   One section for every letter and one section for other symbols.
   The partitioned index is a map with a letter as key and the
   index partiton as value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn partition-index
  [index]
  (-&gt;&gt; index
       (group-by (comp char-to-index-letter first first))
       (map-values #(apply sorted-map (apply concat %)))))</pre></td></tr><tr><td class="docs"><p>Builds a <a href="data-structures.html#CategoryMatch">Category Match</a> between
  the given <code>medium</code> and <code>category</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- compute-matching-score
  [medium category]
  (let [cwidx (:index category)
        mwidx (:index medium)
        word-scores (-&gt;&gt; (keys mwidx)
                         (map (fn [wid] [wid
                                         (* (:match-value (get mwidx wid) 0.0)
                                            (:match-value (get cwidx wid) 0.0))]))
                         (filter #(&gt; (second %) 0))
                         (apply concat)
                         (apply hash-map))
        score (double (apply + (vals word-scores)))]
    {:category-id (:id category)
     :word-scores word-scores
     :score score}))</pre></td></tr><tr><td class="docs"><p>Builds the matches between all categories in the
  <a href="data-structures.html#AnalysisResults">Analysis Results</a> <code>job</code>
  and the given <code>medium</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn match-medium
  [{:keys [categories configuration] :as job} medium]
  (let [matches (if (not (empty? categories))
                  (-&gt;&gt; categories
                       (map #(compute-matching-score medium %))
                       (filter #(&gt;= (:score %) 0.0))
                       (map #(vector (:category-id %) %))
                       (apply concat)
                       (apply sorted-map))
                  {})]
  (assoc medium
    :matches matches
    :max-score (safe-max (map :score (vals matches))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- lookup-matching-score
  [category medium]
  (-&gt; medium
      (get-in [:matches (:id category)] {:word-scores {} :score 0.0})
      (dissoc :category-id)
      (assoc :medium-id (:id medium))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lookup-category-match
  [{:keys [media] :as job} category]
  (let [matches (-&gt;&gt; media
                  (map #(lookup-matching-score category %))
                  (filter #(&gt;= (:score %) 0.0))
                  (map #(vector (:medium-id %) %))
                  (apply concat)
                  (apply sorted-map))]
  (assoc category
    :matches matches
    :max-score (safe-max (map :score (vals matches))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.tasks" name="distillery.tasks"><h1 class="project-name">distillery.tasks</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>The Namespace for Tasks</h1>

<p>A task is a high-level processing step in this application.
Every task deals with a well delimited portion of the processing.
The tasks are used by <a href="#distillery.core">distillery.core</a>.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.tasks
  (:require [clojure.string :as string])
  (:require [clojure.pprint :as pp])
  (:require [clojure.java.browse :refer (browse-url)])
  (:require [mastersign.html :refer (save-page)])
  (:require [mastersign.trace :refer :all])
  (:require [mastersign.files :refer :all])
  (:require [distillery.config :as cfg])
  (:require [distillery.text :refer [txt]])
  (:require [distillery.data :refer :all])
  (:require [distillery.blacklist :refer :all])
  (:require [distillery.processing :as proc])
  (:require [distillery.blacklist :as bl])
  (:require [distillery.xmlresult :as xr])
  (:require [distillery.txtresult :as tr])
  (:require [distillery.view.dependencies :refer (save-dependencies)])
  (:require [distillery.view.base :refer (render)])
  (:require [distillery.view.cloud :refer (build-cloud-word-data build-cloud-ui-data create-cloud)])
  (:require [distillery.view.index :as v-index])
  (:require [distillery.view.category :as v-category])
  (:require [distillery.view.medium :as v-medium])
  (:require [distillery.view.word :as v-word])
  (:require [distillery.view.match :as v-match]))</pre></td></tr><tr><td class="docs"><h2>Helper</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This HOF returns the map function that should be
  used for time consuming transformations.
  The configuration value <code>:parallel-proc</code>
  controls whether <code>pmap</code> or <code>map</code> is returned.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-fn
  [job]
  (if (cfg/value [:configuration :parallel-proc] job)
    #(doall (pmap %1 %2))
    #(doall (map %1 %2))))</pre></td></tr><tr><td class="docs"><p>This macro allows the definition of a pipeline
  similar to <code>-&gt;</code>, but with the automatic generation
  of tracing messages which allow the monitoring of
  the pipeline during execution.</p>

<p>  The first argument <code>pipe-name</code> is the name of the pipeline,
  the second <code>x</code> is the initial argument for the first function
  in the pipeline,
  and the all following arguments <code>fs</code> are functions,
  defining the process steps.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro process-pipeline
  [pipe-name x &amp; fs]
  (let [trc (gensym &quot;trc&quot;)]
  `(let [~trc (fn [x# no#] (trace-message ~(str &quot;PIPELINE_STEP &quot; pipe-name &quot; &quot;) (inc no#)) x#)]
     (trace-message ~(str &quot;PIPELINE &quot; pipe-name &quot; [&quot; (count fs) &quot;]&quot;))
     ~(cons `-&gt;
            (cons x
                  (apply concat
                         (map-indexed
                          (fn [i f]
                            [f `(~trc ~(inc i))])
                          fs)))))))</pre></td></tr><tr><td class="docs"><p>This macro allows a group of potentially parallel tasks
  be executed, and monitored by automatically generated
  trace messages.</p>

<p>  The first argument <code>group-name</code> is a name for the process group,
  the second argument <code>job</code> is a job description and contains the configuration
  for the parallelization,
  the third argument <code>f</code> is a function which is called for every task in the group,
  and all following arguments are process tasks.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro process-task-group
  [group-name job f xs]
  `(let [f# (fn [x#] (let [res# (~f x#)] (trace-message ~(str &quot;TASK_END &quot; group-name)) res#))]
     (trace-message ~(str &quot;TASKGROUP &quot; group-name &quot; [&quot; (count xs) &quot;]&quot;))
     (let [resv# ((map-fn ~job) f# ~xs)]
     (trace-message ~(str &quot;TASKGROUP_END &quot; group-name))
       resv#)))</pre></td></tr><tr><td class="docs"><p>The private var <code>filter-map</code> holds a look-up-table
mapping the filter keywords from the configuration to
actual predicates.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:private filter-map
  {:not-short proc/not-short?
   :noun proc/noun?
   :min-confidence proc/min-confidence?
   :good-confidence proc/good-confidence?
   :no-punctuation proc/no-punctuation?
   :not-in-blacklist bl/not-in-blacklist?})</pre></td></tr><tr><td class="docs"><p>Create the word predicate for the medium index.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- word-predicate
  [{:keys [configuration] :as job}]
  (let [filters (map #(% filter-map) (cfg/value :index-filter configuration))]
    (partial multi-filter (filter #(not (nil? %)) filters))))</pre></td></tr><tr><td class="docs"><h2>Task Functions</h2>

<p>The following public functions represent all process tasks used by the
core tasks in <a href="#distillery.core">distillery.core</a>.
The task functions are accompanied by some private functions,
helping to organize the code of the tasks.</p>

<p>The task functions are grouped by the following goals:</p>

<ul>
<li>Dependencies</li>
<li>Preprocessing and Analysis
<ul><li>Categories</li>
<li>Speech Recognition Results</li>
<li>Similarity Matching</li></ul></li>
<li>XML Result Generation</li>
<li>Text Result Generation</li>
<li>Website Generation
<ul><li>Main Pages</li>
<li>Category Pages</li>
<li>Medium Pages</li></ul></li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs"><h3>Dependencies</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Prepares the output directory by creating
  a number of sub directories and copying site dependencies.</p>
</td><td class="codes"><pre class="brush: clojure">(defn prepare-output-dir
  [{:keys [output-dir]}]
  (trace-message &quot;Preparing output directory &quot; output-dir)
  (create-dir output-dir)
  (create-dir output-dir &quot;categories&quot;)
  (create-dir output-dir &quot;media&quot;)
  (create-dir output-dir &quot;words&quot;)
  (save-dependencies output-dir))</pre></td></tr><tr><td class="docs"><h3>Preprocessing and Analysis</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><h4>Categories</h4>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Loads a single resource for a category.
  The resource is defined by an absolute path to a local file or an URL. If both are given, the local file takes precedence.
  The resource can have one of the following types:</p>

<ul>
<li><code>:plain</code> A plain text file, which can be simply tokenized to extract the words</li>
<li><code>:html</code> A HTML file, where the text is extracted by taking the page body
and concatenating all textual content from the markup.</li>
<li><p><code>:wikipedia</code> A Wikipedia page, which is preprocessed
to remove the navigation elements and some common headlines
which occur in every Wikipedia page.</p>

<p>The preprocessing functions to extract the words from the resources
reside in <a href="#distillery.data">distillery.data</a>.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn- load-category-resource
  [{:keys [id]} {:keys [type url file] :as resource}]
  (trace-message &quot;Loading category resource &quot; file)
  (let [url (if file (str &quot;file:///&quot; file) url)]
    (assoc resource :words
      (-&gt; (case type
            :plain (load-text url)
            :html (load-text-from-html url)
            :wikipedia (load-text-from-wikipedia url))
          words-from-text))))</pre></td></tr><tr><td class="docs"><p>Loads all resources for one category.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- load-category-resources
  [job {:keys [id resources] :as category}]
  (trace-message &quot;Loading category resources for '&quot; id &quot;'&quot;)
  (let [resources* ((map-fn job) #(load-category-resource category %) resources)
        words (apply concat (map :words resources*))]
    (assoc category
      :resources resources*
      :words words)))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Loads all resources for all categories.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-categories
  [{:keys [categories] :as job}]
  (trace-block
   &quot;Loading category resources&quot;
   (assoc job :categories
     (vec ((map-fn job) #(load-category-resources job %) categories)))))</pre></td></tr><tr><td class="docs"><p>Extends a <a href="data-structures.html#CategoryDescription">Category Description</a>
  by adding the slot <code>:words</code> with a collection of
  <a href="data-structures.html#DescriptiveWord">Descriptive Words</a>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- build-category-words
  [{:keys [id words] :as category}]
  (trace-message &quot;Building words for category '&quot; id &quot;'&quot;)
  (assoc category :words
    (map-indexed
     (fn [i w] {:no i
                :text w
                :lexical-form w
                :confidence 1})
     words)))</pre></td></tr><tr><td class="docs"><p>Extends a <a href="data-structures.html#CategoryDescription">Category Description</a>
  by adding the slot <code>:index</code> with a map pointing to
  <a href="data-structures.html#CategoryWords">Category Words</a> and
  the slot <code>:index-stats</code> with the <a href="data-structures.html#IndexStatistics">Index Statistics</a>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- build-category-index
  [job category]
  (trace-message &quot;Building index for category '&quot; (:id category) &quot;'&quot;)
  (proc/add-category-word-index category :predicate (word-predicate job)))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Analyzes the categories and generates the index structures.</p>
</td><td class="codes"><pre class="brush: clojure">(defn analyze-categories
  [job]
  (trace-block
   &quot;Analyzing categories&quot;
   (let [job* (update-in
               job [:categories]
               (fn [categories]
                 (vec ((map-fn job)
                       (fn [category]
                         (build-category-index
                          job
                          (build-category-words category)))
                       categories))))]
     job*)))</pre></td></tr><tr><td class="docs"><h4>Speech Recognition Results</h4>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Loads the <a href="data-structures.html#SpeechRecognitionResult">Speech Recognition Result</a>
  for a medium and extends the <a href="data-structures.html#MediumDescription">Medium Description</a>
  by the slot <code>:results</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- load-speech-recognition-result
  [{:keys [id results-file] :as medium}]
  (trace-message &quot;Loading results of &quot; id)
  (let [results (-&gt; results-file
                    load-data
                    proc/strip-alternates
                    proc/reverse-index-results)]
    (assoc medium :results results)))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Loads the speech recognition results for all media.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-speech-recognition-results
  [job]
  (trace-block
   &quot;Loading speech recognition results&quot;
   (update-in job [:media]
              #(vec ((map-fn job) load-speech-recognition-result %)))))</pre></td></tr><tr><td class="docs"><p>Extends a <a href="data-structures.html#MediumDescription">Medium Description</a>
  by the slots <code>:phrase-count</code>, <code>:word-count</code>, and <code>:confidence</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- build-medium-statistics
  [{:keys [id results] :as medium}]
  (trace-message &quot;Building statistics for medium '&quot; id &quot;'&quot;)
  (assoc medium
    :phrase-count (count results)
    :word-count (count (proc/words results))
    :confidence (mean (map :confidence results))))</pre></td></tr><tr><td class="docs"><p>Extends a <a href="data-structures.html#MediumDescription">Medium Description</a>
  by the slot <code>:index</code>, which is a map, pointing to <a href="data-structures.html#MediumWord">Medium Words</a>,
  and by the slot <code>:index-stats</code>, which holds the <a href="data-structures.html#IndexStatistics">Index Statistics</a>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- build-medium-index
  [job medium]
  (trace-message &quot;Building index for medium '&quot; (:id medium) &quot;'&quot;)
  (proc/add-medium-word-index medium :predicate (word-predicate job)))</pre></td></tr><tr><td class="docs"><p>Merges the medium indexes into one global <a href="data-structures.html#WordIndex">Word Index</a>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- build-global-index
  [{:keys [media]}]
  (trace-block
   &quot;Merging indexes&quot;
   (apply (partial merge-with proc/merge-index-entries) (map :index media))))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Analyzes the speech recognition results and generates the index structures including
  the <a href="data-structures.html#MediumWord">Medium Words</a> and the <a href="data-structures.html#WordIndex">Word Index</a>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn analyze-speech-recognition-results
  [job]
  (trace-block
   &quot;Analyzing media&quot;
   (let [job* (update-in
               job [:media]
               (fn [media]
                 (vec ((map-fn job)
                       (fn [medium] (build-medium-index job (build-medium-statistics medium)))
                       media))))
         job* (assoc job*
                :words (build-global-index job*))]
     job*)))</pre></td></tr><tr><td class="docs"><h4>Similarity Matching</h4>
</td><td class="codes"></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Matches the <a href="data-structures.html#MediumWord">Medium Words</a> of all media against
  the <a href="data-structures.html#CategoryWords">Category Words</a> of all categories
  and completes the given <a href="data-structures.html#MediumResult">Medium Results</a>
  with the slots <code>:matches</code> and <code>:max-score</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn match-media
  [{:keys [media] :as job}]
  (trace-block
   &quot;Matching media against categories&quot;
   (assoc job
     :media (vec ((map-fn job)
                   (partial proc/match-medium job)
                   media)))))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Looks up the matching scores from the <a href="data-structures.html#MediumResult">Medium Results</a>
  and adds them to the <a href="data-structures.html#CategoryResult">Category Results</a>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn lookup-categories-matches
  [{:keys [categories] :as job}]
  (trace-block
   &quot;Looking up category matching scores against media&quot;
   (assoc job
     :categories (vec (map
                       (partial proc/lookup-category-match job)
                       categories)))))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Builds some statistic values over the matching scores for the whole job.</p>

<p>  Completes the given <a href="data-structures.html#AnalysisResults">Analysis Results</a>
  by adding the slots <code>:max-score</code> and <code>:max-word-score</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn matching-stats
  [job]
  (let [matches (mapcat #(vals (:matches %)) (:media job))
        scores (map :score matches)
        word-scores (mapcat #(vals (:word-scores %)) matches)]
        (assoc job
          :max-score (safe-max scores)
          :max-word-score (safe-max word-scores))))</pre></td></tr><tr><td class="docs"><h3>XML Result Generation</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Writes the essential analysis and matching results to a XML file,
  specified by the <a href="data-structures.html#JobDescription">Job Description</a>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn save-result-as-xml
  [{:keys [output-dir result-file] :as job}]
  (let [path (combine-path output-dir result-file)]
    (xr/save-result path job))
  nil)</pre></td></tr><tr><td class="docs"><h3>Text Result Generation</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Writes a text file with all recognized phrases for each medium.</p>
</td><td class="codes"><pre class="brush: clojure">(defn save-result-as-txt
  [{:keys [output-dir] :as job}]
  (doseq [medium (:media job)]
    (let [dir (combine-path output-dir &quot;media&quot; (:id medium))
          path (combine-path dir &quot;transcript.txt&quot;)]
      (when (not (file-exists? dir))
        (create-dir dir))
      (tr/save-result medium path)))
  nil)</pre></td></tr><tr><td class="docs"><h3>Website Generation</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Builds the main menu structure.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-main-menu
  [{:keys [categories] :as args}]
  [[(txt :frame-top-menu-project) &quot;index.html&quot;]
   (when (seq categories)
     [(txt :frame-top-menu-categories) &quot;categories.html&quot;])
   [(txt :frame-top-menu-media) &quot;media.html&quot;]])</pre></td></tr><tr><td class="docs"><p>Generates a HTML page by calling the page function <code>page-f</code>
  with the <a href="data-structures.html#AnalysisResults">Analysis Results</a> <code>args</code>.
  Saves the generated page in the <code>output-dir</code> of the job.
  The filename of the page is specified by the <code>page-name</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-page
  [page-name page-f {:keys [output-dir] :as args}]
  (let [target-file (combine-path output-dir page-name)
        page-def (-&gt; args
                     page-f
                     (concat [:main-menu (create-main-menu args)]))
        page (apply render page-def)]
    (save-page target-file page)))</pre></td></tr><tr><td class="docs"><p>Generates a HTML include file by calling the include function <code>include-f</code>
  with the <a href="data-structures.html#AnalysisResults">Analysis Results</a> <code>args</code>.
  Saves the generated include in the <code>output-dir</code> of the job.
  The filename of the include is specified by the <code>include-name</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-include
  [include-name include-f {:keys [output-dir] :as args}]
  (let [target-file (combine-path output-dir include-name)]
    (-&gt;&gt; args
         include-f
         (save-page target-file))))</pre></td></tr><tr><td class="docs"><h4>Main Pages</h4>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Creates the include file for a word in the global context.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-word-include
  [{:keys [output-dir] :as job} {:keys [path] :as word}]
  (create-include
    (str path &quot;.inc.html&quot;)
    v-word/render-word-include
    (assoc job :word word)))</pre></td></tr><tr><td class="docs"><p>Create the include files for all words of the project.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-word-includes
  [{:keys [output-dir configuration words] :as job}]
  (if (cfg/value :skip-word-includes configuration)
    (trace-message &quot;Skipping global word includes&quot;)
    (trace-block
     &quot;Creating global word includes&quot;
     (let [words-path &quot;words&quot;]
       (create-dir (combine-path output-dir words-path))
       ((map-fn job)
        (fn [word]
          (let [word-path (combine-path words-path (:id word))]
            (create-word-include job (assoc word :path word-path))))
        (vals words))))))</pre></td></tr><tr><td class="docs"><p>Creates the word cloud for the global context.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-main-cloud
  [{:keys [output-dir configuration words] :as job}]
  (if (cfg/value :skip-wordclouds configuration)
    (do (trace-message &quot;Skipping global wordcloud&quot;) [])
    (trace-block
     &quot;Creating global wordcloud&quot;
     (build-cloud-ui-data (create-cloud (build-cloud-word-data words configuration :main-cloud)
                                        (combine-path output-dir &quot;cloud.png&quot;)
                                        configuration
                                        :main-cloud)))))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Creates the main page for the website including the
  global word cloud and the include files for all words.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-index-page
  [job]
  (trace-message &quot;Creating index page&quot;)
  (let [cloud (create-main-cloud job)
        job* (assoc job :cloud cloud)
        pwords (proc/partition-index (:words job*))
        job* (assoc job* :pwords pwords)]
    (create-page &quot;index.html&quot; v-index/render-main-page job*)
    (create-word-includes job*)))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Creates the overview page for all categories.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-categories-page
  [job]
  (trace-message &quot;Creating categories overview page&quot;)
  (create-page &quot;categories.html&quot; v-index/render-categories-page job))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Creates the overview page for all media.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-media-page
  [job]
  (trace-message &quot;Creating media overview page&quot;)
  (create-page &quot;media.html&quot; v-index/render-media-page job))</pre></td></tr><tr><td class="docs"><h4>Category Pages</h4>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Creates the include file for a word in the context of a category.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-category-word-include
  [{:keys [output-dir] :as job} category {:keys [path] :as word}]
  (create-include
    (str path &quot;.inc.html&quot;)
    v-word/render-category-word-include
    (assoc job :category category :word word)))</pre></td></tr><tr><td class="docs"><p>Create includes for all words of a category.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-category-word-includes
  [{:keys [output-dir configuration] :as job} {:keys [id index path] :as category}]
  (if (cfg/value :skip-word-includes configuration)
    (trace-message &quot;Skipping word includes for category '&quot; id &quot;'&quot;)
    (trace-block
     (str &quot;Creating word includes for category '&quot; id &quot;'&quot;)
     (let [words-path (combine-path path &quot;words&quot;)]
       (create-dir (combine-path output-dir words-path))
       ((map-fn job)
        (fn [word]
          (let [word-path (combine-path words-path (:id word))]
            (create-category-word-include job category (assoc word :path word-path))))
        (vals index))))))</pre></td></tr><tr><td class="docs"><p>Creates the include file for a match in the context of a category.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-category-match-include
  [{:keys [output-dir] :as job} category {:keys [path] :as match}]
  (create-include
    (str path &quot;.inc.html&quot;)
    v-match/render-category-match-include
    (assoc job :category category :match match)))</pre></td></tr><tr><td class="docs"><p>Create includes for all medium matches of a category.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-category-match-includes
  [{:keys [output-dir configuration] :as job} {:keys [id matches path] :as category}]
  (if (cfg/value :skip-match-includes configuration)
    (trace-message &quot;Skipping match includes for category '&quot; id &quot;'&quot;)
    (trace-block
     (str &quot;Creating match includes for category '&quot; id &quot;'&quot;)
     (let [matches-path (combine-path path &quot;matches&quot;)]
       (create-dir (combine-path output-dir matches-path))
       ((map-fn  job)
        (fn [match]
          (let [match-path (combine-path matches-path (:medium-id match))]
            (create-category-match-include job category (assoc match :path match-path))))
        (vals matches))))))</pre></td></tr><tr><td class="docs"><p>Creates the word cloud for a category.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-category-cloud
  [{:keys [output-dir configuration] :as job} {:keys [id index path] :as category}]
  (if (cfg/value :skip-wordclouds configuration)
    (do (trace-message &quot;Skipping wordcloud for category '&quot; id &quot;'&quot;) [])
    (trace-block
     (str &quot;Creating wordcloud for category '&quot; id &quot;'&quot;)
     (build-cloud-ui-data (create-cloud (build-cloud-word-data index configuration :category-cloud)
                                        (combine-path output-dir path &quot;cloud.png&quot;)
                                        configuration
                                        :category-cloud)))))</pre></td></tr><tr><td class="docs"><p>Create the main page for a certain category.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-category-page
  [{:keys [output-dir] :as job} {:keys [id index] :as category}]
  (trace-message &quot;Creating category page for '&quot; id &quot;'&quot;)
  (let [category-path (combine-path &quot;categories&quot; id)]
    (create-dir (combine-path output-dir category-path))
    (let [category* (assoc category :path category-path)
          cloud (create-category-cloud job category*)
          category* (assoc category* :cloud cloud)
          pindex (proc/partition-index index)
          category* (assoc category* :pindex pindex)
          args (assoc job :category category*)]
      (create-page
       (combine-path category-path &quot;index.html&quot;)
       v-category/render-category-page
       args)
      (create-category-word-includes job category*)
      (create-category-match-includes job category*))))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Creates one page for every category
  including the word clouds and the word include files.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-category-pages
  [job]
  (trace-block
   &quot;Creating category pages&quot;
   (doall
    ((map-fn job)
     #(create-category-page job %)
     (:categories job))))
  nil)</pre></td></tr><tr><td class="docs"><h4>Media Pages</h4>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Creates the include file for a word in the context of a medium.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-medium-word-include
  [{:keys [output-dir] :as job} medium {:keys [path] :as word}]
  (create-include
    (str path &quot;.inc.html&quot;)
    v-word/render-medium-word-include
    (assoc job :medium medium :word word)))</pre></td></tr><tr><td class="docs"><p>Create includes for all words of a medium.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-medium-word-includes
  [{:keys [output-dir configuration] :as job} {:keys [id index path] :as medium}]
  (if (cfg/value :skip-word-includes configuration)
    (trace-message &quot;Skipping word includes for medium '&quot; id &quot;'&quot;)
    (trace-block
     (str &quot;Creating word includes for medium '&quot; id &quot;'&quot;)
     (let [words-path (combine-path path &quot;words&quot;)]
       (create-dir (combine-path output-dir words-path))
       ((map-fn job)
        (fn [word]
          (let [word-path (combine-path words-path (:id word))]
            (create-medium-word-include job medium (assoc word :path word-path))))
        (vals index))))))</pre></td></tr><tr><td class="docs"><p>Creates the word cloud for a medium.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-medium-cloud
  [{:keys [output-dir configuration] :as job} {:keys [id index path] :as medium}]
  (if (cfg/value :skip-wordclouds configuration)
    (do (trace-message &quot;Skipping wordcloud for medium '&quot; id &quot;'&quot;) [])
    (trace-block
     (str &quot;Creating wordcloud for &quot; id)
     (build-cloud-ui-data (create-cloud (build-cloud-word-data index configuration :medium-cloud)
                                        (combine-path output-dir path &quot;cloud.png&quot;)
                                        configuration
                                        :medium-cloud)))))</pre></td></tr><tr><td class="docs"><p>Create the main page for a certain medium.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- create-medium-page
  [{:keys [output-dir configuration] :as job} {:keys [id index encoded-media-files] :as medium}]
  (trace-message &quot;Creating medium page for '&quot; id &quot;'&quot;)
  (let [medium-path (combine-path &quot;media&quot; id)]
    (create-dir (combine-path output-dir medium-path))
    (let [medium* (assoc medium :path medium-path)
          cloud (create-medium-cloud job medium*)
          medium* (assoc medium* :cloud cloud)
          pindex (proc/partition-index index)
          medium* (assoc medium* :pindex pindex)
          encoded-media-files* (map #(assoc % :ext (file-name-ext (:path %))) encoded-media-files)
          medium* (assoc medium* :encoded-media-files encoded-media-files*)
          args (assoc job :medium medium*)]
      (if (cfg/value :skip-media-copy configuration)
        (trace-message &quot;Skipping copy mediafile for medium '&quot; id &quot;'&quot;)
        (do
          (trace-message &quot;Copy media files for medium '&quot; id &quot;'&quot;)
          (doseq [{:keys [path ext]} encoded-media-files*]
            (let [medium-target-file (combine-path output-dir medium-path (str id ext))]
              (when (not (file-exists? medium-target-file))
                (copy-file (get-path path) (get-path medium-target-file)))))))
      (create-page
       (combine-path medium-path &quot;index.html&quot;)
       v-medium/render-medium-page
       args)
      (create-medium-word-includes job medium*))))</pre></td></tr><tr><td class="docs"><p><strong>TASK</strong> - Creates one page for every medium
  including the word clouds and the word include files.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-medium-pages
  [job]
  (trace-block
   &quot;Creating medium pages&quot;
   (doall
    ((map-fn job)
     #(create-medium-page job %)
     (:media job))))
  nil)</pre></td></tr><tr><td class="docs"><h2>Debug Tasks</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-reverse-indexed-results
  [{:keys [medium]}]
  (let [results (load-data (:results-file medium))]
    (pp/pprint (proc/reverse-index-results [(first results)]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn show-main-page
  [{:keys [output-dir]}]
  (-&gt; (combine-path output-dir &quot;/index.html&quot;)
      get-path
      .toUri
      .toString
      browse-url))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.text" name="distillery.text"><h1 class="project-name">distillery.text</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.text
  (:require [clojure.java.io :refer (resource)])
  (:require [distillery.data :refer (load-data)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def resources (load-data (resource &quot;text.edn&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn txt
  [id]
  (let [v (get resources id (format &quot;TEXT WITH ID '%s' NOT FOUND!&quot; (name id)))]
    (if (keyword? v) (txt v) v)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.txtresult" name="distillery.txtresult"><h1 class="project-name">distillery.txtresult</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.txtresult
  (:import [java.util Locale])
  (:require [clojure.string :as str])
  (:require [clojure.java.io :refer (writer)])
  (:require [mastersign.files :refer :all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn save-result
  [medium file]
  (with-open [w (writer file)]
    (doseq [result (:results medium)]
        (.write w (str/join &quot; &quot; (map :text (:words result))))
        (.write w (format &quot;%n&quot;)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.base" name="distillery.view.base"><h1 class="project-name">distillery.view.base</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.base
  (:require [net.cgrand.enlive-html :as eh])
  (:require [mastersign.html :refer :all])
  (:require [mastersign.files :refer :all])
  (:require [distillery.text :refer [txt]])
  (:require [distillery.view.defaults :as defaults])
  (:require [distillery.view.html :refer :all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fix-url
  [base-path url]
  (let [uri (java.net.URI. url)]
    (if (or (= (.getScheme uri) &quot;javascript&quot;) (.isAbsolute uri))
      url
      (str base-path url))))</pre></td></tr><tr><td class="docs"><p>Fixes all relative URLs in the template by suffixing with the given base path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fix-urls
  [base-path template]
  (let [fix-url (partial fix-url base-path)
        fix-href (attr-transformer :href fix-url)
        fix-src (attr-transformer :src fix-url)]
    (eh/at template
           [:head :link] fix-href
           [:script] fix-src
           [:a] fix-href
           [:img] fix-href)))</pre></td></tr><tr><td class="docs"><p>Fixes all relative URLs in the menu by suffixing with the given base path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fix-menu-urls
  [base-path menu]
  (let [map-map (fn [f m] (map (fn [pair] (when pair [(first pair) (f (second pair))])) m))]
    (map-map (partial fix-url base-path) menu)))</pre></td></tr><tr><td class="docs"><p>Renders the layout template.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render
  [&amp; {:keys [base-path
             title
             js-code
             main-menu
             main-menu-title
             secondary-menu
             secondary-menu-title
             head
             page
             foot]}]
  (let [title-prefix (txt :frame-title-prefix)
        title (if title
                (if title-prefix (str title-prefix &quot; - &quot; title) title)
                title-prefix)
        js-code (if js-code (str &quot;$(function () { &quot; js-code &quot; });&quot;) nil)
        head (or head (headline 1 title))
        foot (or foot defaults/copyright)
        main-menu (menu
                    (fix-menu-urls base-path (or main-menu defaults/main-menu))
                    :title (or main-menu-title defaults/main-menu-title))
        secondary-menu (if secondary-menu
                         (menu
                           secondary-menu
                           :title (or secondary-menu-title defaults/secondary-menu-title))
                         nil)]
    (eh/at (fix-urls base-path (template &quot;base&quot;))
	    [:head :title] (eh/content title)
	    [:head :script#js_code] (eh/content js-code)
	    [:nav#main-menu] (eh/content main-menu)
	    [:nav#secondary-menu] (eh/content secondary-menu)
	    [:header] (eh/content head)
	    [:#page] (eh/content page)
	    [:footer] (eh/content foot))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.category" name="distillery.view.category"><h1 class="project-name">distillery.view.category</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.category
  (:require [clojure.string :as string])
  (:require [net.cgrand.enlive-html :as eh])
  (:require [mastersign.html :refer :all])
  (:require [mastersign.files :refer :all])
  (:require [distillery.config :as cfg])
  (:require [distillery.text :refer [txt]])
  (:require [distillery.view.cloud :as cloud])
  (:require [distillery.view.glossary :as glossary])
  (:require [distillery.view.hitlist :as hitlist])
  (:require [distillery.view.html :refer :all]))</pre></td></tr><tr><td class="docs"><p>Creates the headline for the medium page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-headline
  [{:keys [category]}]
  (headline 2 (:name category)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-hitlist
  [{:keys [configuration] :as job} {:keys [id index] :as category}]
  (hitlist/render-occurrence-hitlist
   (vals index)
   :occurrences
   configuration
   :category-cloud))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the overview page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-overview
  [{:keys [category] :as job}]
  (innerpage &quot;overview&quot; (txt :category-overview-h) true
             [(ulist &quot;category_statistic&quot;
                    [(list-item (str (txt :category-overview-resource-count) (count (:resources category))))
                     (list-item (str (txt :category-overview-word-count) (count (:words category))))
                     (list-item (str (txt :category-overview-index-size) (count (:index category))))])
              (headline 4 (txt :category-overview-hitlist-h))
              (paragraph &quot;explanation&quot; (txt :category-overview-hitlist-d))
              (render-hitlist job category)]))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the category glossary page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-glossary
  [{{:keys [pindex] :as category} :category :as args}]
  (innerpage &quot;glossary&quot; (txt :category-glossary-h) false
             [(paragraph &quot;explanation&quot; (txt :category-glossary-d))
              (glossary/render-glossary pindex)]))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the overview page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-cloud
  [{{:keys [id cloud] :as category} :category :as args}]
  (innerpage &quot;cloud&quot; (txt :category-wordcloud-h) false
             [(paragraph &quot;explanation&quot; (txt :category-wordcloud-d))
              (cloud/render-cloud id cloud)]))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the overview page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-media
  [{:keys [media category max-score configuration] :as args}]
  (let [medium-fn (fn [mid] (first (filter #(= mid (:id %)) media)))]
    (innerpage &quot;media&quot; (txt :category-media-h) false
               [(paragraph &quot;explanation&quot; (txt :category-media-d))
                (hitlist/render-medium-matchlist
                 category
                 media
                 configuration)])))</pre></td></tr><tr><td class="docs"><p>Create the HTML for the word frame.
   The word frame is an empty container to load a category word page into.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-category-word-frame
  [args]
  (innerpage &quot;word&quot; (txt :category-word-h) false nil))</pre></td></tr><tr><td class="docs"><p>Create the HTML for the match frame.
   The word frame is an empty container to load a category match page into.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-category-match-frame
  [args]
  (innerpage &quot;match&quot; (txt :category-match-h) false nil))</pre></td></tr><tr><td class="docs"><p>Renders the main page for a category.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-category-page
  [{:keys [job-name category configuration] :as args}]
  [:base-path &quot;../../&quot;
   :title (build-title args (txt :category-title))
   :secondary-menu [[(txt :category-menu-overview) (jshref &quot;innerpage('overview')&quot;)]
                    (when-not (cfg/value :skip-wordclouds configuration)
                      [(txt :category-menu-wordcloud) (jshref &quot;innerpage('cloud')&quot;)])
                    [(txt :category-menu-media) (jshref &quot;innerpage('media')&quot;)]
                    [(txt :category-menu-glossary) (jshref &quot;innerpage('glossary')&quot;)]]
   :page
     [(render-headline args)
      (render-overview args)
      (render-glossary args)
      (render-cloud args)
      (render-media args)
      (render-category-word-frame args)
      (render-category-match-frame args)]])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.cloud" name="distillery.view.cloud"><h1 class="project-name">distillery.view.cloud</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.cloud
  (:require [clojure.string :as string])
  (:require [mastersign.drawing :as mdr])
  (:require [mastersign.wordcloud :as mwc])
  (:require [mastersign.html :refer :all])
  (:require [distillery.config :as cfg])
  (:require [distillery.view.html :refer :all]))</pre></td></tr><tr><td class="docs"><p>Transforms the word meta-data from an index
  into the input format for the cloud generator.</p>
</td><td class="codes"><pre class="brush: clojure">(defn build-cloud-word-data
  [index config cloud-key]
  (let [max-occurrence (double (dec (apply max (cons 0 (map #(count (:occurrences %)) (vals index))))))]
    (vec
     (map
      (fn [w]
        (let [occurrence (dec (count (:occurrences w)))
              confidence (/ (- (:mean-confidence w) (cfg/value :min-confidence config))
                            (- 1 (cfg/value :min-confidence config)))]
          [(:id w)
           (:lexical-form w)
           (if (&gt; max-occurrence 0) (/ occurrence max-occurrence) 0.5)
           (* confidence confidence)]))
      (filter #(&gt;= (count (:occurrences %)) (cfg/value [cloud-key :min-occurrence] config)) (vals index))))))</pre></td></tr><tr><td class="docs"><p>Transforms the result data from the cloud generator
  into the format required to generate the UI on top of the cloud.</p>
</td><td class="codes"><pre class="brush: clojure">(defn build-cloud-ui-data
  [{:keys [word-infos]}]
  (str &quot;[&quot;
       (-&gt;&gt; word-infos
            (sort-by :v1)
            (map (fn
                   [{:keys [id ^java.awt.geom.Rectangle2D$Float rect]}]
                   (str &quot;{id:'&quot; id &quot;',r:{x:&quot;(.x rect)&quot;,y:&quot;(.y rect)&quot;,w:&quot;(.width rect)&quot;,h:&quot;(.height rect)&quot;}}&quot;)))
            (string/join &quot;,&quot;))
       &quot;]&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-cloud
  [id, cloud]
  {:tag :figure
   :attrs {:class &quot;wordcloud&quot;
           :data-cloud-id id}
   :content [{:tag :img
              :attrs {:class &quot;wordcloud&quot;
                      :src &quot;cloud.png&quot;}}
             (jscript (str &quot;register_cloud_data('&quot; id &quot;',&quot; cloud &quot;);&quot;))]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-cloud
  [word-data target-path config cloud-key]
  (let [ccv (fn [k] (cfg/value [cloud-key k] config))]
    (mwc/create-cloud word-data
                      :target-file target-path
                      :width (ccv :width)
                      :height (ccv :height)
                      :precision (case (ccv :precision) :low 0.2 :medium 0.4 :high 0.6 0.4)
                      :order-priority (ccv :order-priority)
                      :font (apply mdr/font (concat [(ccv :font-family) 20] (ccv :font-style)))
                      :min-font-size (ccv :min-font-size)
                      :max-font-size (ccv :max-font-size)
                      :color-fn #(apply mdr/color (concat (take 3 (ccv :color)) [(+ 0.25 (* % 0.75))]))
                      :background-color (apply mdr/color (ccv :background-color)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.defaults" name="distillery.view.defaults"><h1 class="project-name">distillery.view.defaults</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.defaults
  (:require [distillery.text :refer [txt]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def main-menu-title (txt :frame-top-menu-title))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def secondary-menu-title (txt :frame-menu-title))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def main-menu
  [[(txt :frame-top-menu-project) &quot;index.html&quot;]
   [(txt :frame-top-menu-categories) &quot;categories.html&quot;]
   [(txt :frame-top-menu-media) &quot;media.html&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def copyright
  {:tag :p
   :content
    [&quot;Copyright \u00A9 &quot;
     (.get (java.util.GregorianCalendar.) java.util.Calendar/YEAR)
    &quot; &quot;
    {:tag :a
     :attrs {:href (txt :copyright-href) :target &quot;_blank&quot;}
     :content [(txt :copyright-holder)]}
    &quot;.&quot;]})</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.dependencies" name="distillery.view.dependencies"><h1 class="project-name">distillery.view.dependencies</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.dependencies
  (:import [java.io InputStream])
  (:import [java.nio.file Path Files CopyOption StandardCopyOption])
  (:require [clojure.java.io :as io])
  (:require [mastersign.files :refer :all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def static-resources
  [&quot;reset.css&quot;
   &quot;base.css&quot;
   &quot;layout.css&quot;
   &quot;distillery.css&quot;
   &quot;jquery.js&quot;
   &quot;distillery.js&quot;
   ])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- copy-stream-to-file
  [^InputStream s ^Path p]
  (Files/copy s p (into-array CopyOption [StandardCopyOption/REPLACE_EXISTING])))</pre></td></tr><tr><td class="docs"><p>Saves a static resource dependency relative to the given HTML file path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- save-dependency
  [^String target-dir ^String rn]
  (let [src-s (.getResourceAsStream (.getContextClassLoader (Thread/currentThread)) rn)
        trg (get-path target-dir rn)]
    (copy-stream-to-file src-s trg)
    (.close src-s)))</pre></td></tr><tr><td class="docs"><p>Saves all static resource dependencies relative to the given HTML file path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn save-dependencies
  [^String target-dir]
  (doseq [rn static-resources]
    (save-dependency target-dir rn)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.glossary" name="distillery.view.glossary"><h1 class="project-name">distillery.view.glossary</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.glossary
  (:require [mastersign.html :refer :all])
  (:require [distillery.view.html :refer :all]))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for a glossary entry.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-glossary-word
  [{:keys [id lexical-form occurrences] :as word}]
  (list-item (jslink (str &quot;word('&quot; id &quot;')&quot;) lexical-form)))</pre></td></tr><tr><td class="docs"><p>Creates an identifier for a glossary partition by its letter.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- glossary-partition-id
  [letter]
  (if (= \? letter) &quot;SYM&quot; (str letter)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- letter-list
  []
  (map char (concat (range 65 91) [63])))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the navigation bar of a glossary.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-glossary-navigation
  [pindex]
  (let [letters (letter-list)]
    (div &quot;glossary-nav&quot;
      (map (fn [l]
             (if (contains? pindex l)
               (jslink (str &quot;glossary('&quot; (glossary-partition-id l) &quot;')&quot;) (str l &quot;  &quot;))
               (str l &quot;  &quot;)))
           letters))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- first-letter
  [pindex]
  (let [index-letters (map first pindex)]
    (-&gt;&gt; (letter-list)
         (filter (fn [l] (map #(= % l) index-letters)))
         first)))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for a partion of a glossary.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-glossary-partition
  [first-letter [letter index-part]]
  {:tag :div
     :attrs {:id (str &quot;glossary-part-&quot; (glossary-partition-id letter))
             :class &quot;glossary-part&quot;
             :style (if (= letter first-letter) &quot;display:block;&quot; &quot;display:none;&quot;)}
     :content [(ulist &quot;glossary&quot; (map render-glossary-word (vals index-part)))]})</pre></td></tr><tr><td class="docs"><p>Create the HTML for a glossary.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-glossary
  [pindex]
  (let [fl (first-letter pindex)]
    {:tag :div
     :attrs {:class &quot;glossary&quot;}
     :content (vec (cons
                    (render-glossary-navigation pindex)
                    (map (partial render-glossary-partition fl) pindex)))}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.hitlist" name="distillery.view.hitlist"><h1 class="project-name">distillery.view.hitlist</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.hitlist
  (:require [mastersign.html :refer :all])
  (:require [distillery.config :as cfg])
  (:require [distillery.data :refer :all])
  (:require [distillery.text :refer [txt]])
  (:require [distillery.view.html :refer :all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-occurrence-hitlist
  [words occ-fn config cloud-key]
  (let [hitlist (take 10 (reverse (sort-by #(count (occ-fn %)) words)))
        max-occ (count (occ-fn (first hitlist)))
        color (or (cfg/value [cloud-key :color] config) [0 0 0])
        conf-fn (fn [cnf]
                  (let [minc (cfg/value :min-confidence config)
                        cnf* (/ (- cnf minc) (- 1 minc))]
                    (* cnf* cnf*)))
        stats-str-fn (if (== 1 (mean (map :mean-confidence hitlist)))
                       (fn [n c] (str n))
                       (fn [n c] (str n &quot; | &quot; (format &quot;%2.1f%%&quot; (* 100.0 c)))))
        item-gen (fn [{:keys [id lexical-form pronunciation mean-confidence] :as w}]
                   (let [num-occ (count (occ-fn w))]
                     (list-item
                      (bar
                       [(span &quot;hitlist_text&quot;
                              (jslink
                               (str &quot;word('&quot; id &quot;');&quot;)
                               {:tag :span
                                :attrs {:title pronunciation}
                                :content lexical-form}))
                        (span &quot;hitlist_stats&quot;
                              (strong (stats-str-fn num-occ mean-confidence)))]
                       color
                       (/ num-occ max-occ)
                       (conf-fn mean-confidence)))))]
    (div &quot;hitlist&quot;
         [(olist (map item-gen hitlist))])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-category-matchlist
  [{:keys [matches max-score] :as medium} categories config]
  (let [matchlist (-&gt;&gt; matches
                       (filter #(&gt;= (:score (second %)) (cfg/value [:min-match-score] config)))
                       (sort-by #(:score (second %)))
                       reverse)
        color (or (cfg/value [:category-cloud :color] config) [0 0 0])
        stats-str-fn (fn [score rel-score]
                       (format &quot;%1.3f | %05.1f%%&quot; score (* rel-score 100)))
        item-gen (fn [[category-id {:keys [score] :as m}]]
                   (let [category (first (filter #(= (:id %) category-id) categories))
                         rel-score (/ score max-score)]
                     (list-item
                      (bar
                       [(span &quot;hitlist_text&quot;
                              (link
                               (str &quot;../../categories/&quot; category-id &quot;/index.html?match=&quot; (:id medium))
                               (:name category)))
                        (span &quot;hitlist_stats&quot;
                              (strong (stats-str-fn score rel-score)))]
                       color
                       rel-score))))]
    (div &quot;hitlist&quot;
         [(olist (map item-gen matchlist))])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-medium-matchlist
  [{:keys [matches] :as category} media config]
  (let [rel-score-fn (fn [match] (let [medium (first (filter #(= (:id %) (:medium-id match)) media))
                                       max-score (:max-score medium)]
                                   (/ (:score match) max-score)))
        matchlist (-&gt;&gt; matches
                       (filter #(&gt;= (:score (second %)) (cfg/value [:min-match-score] config)))
                       (sort-by #(rel-score-fn (second %)))
                       reverse)
        color (or (cfg/value [:medium-cloud :color] config) [0 0 0])
        stats-str-fn (fn [score rel-score]
                       (format &quot;%1.3f | %05.1f%%&quot; score (* rel-score 100)))
        item-gen (fn [[medium-id {:keys [score] :as m}]]
                   (let [medium (first (filter #(= (:id %) medium-id) media))
                         rel-score (rel-score-fn m)]
                     (list-item
                      (bar
                       [(span &quot;hitlist_text&quot;
                              (link
                               (str &quot;../../media/&quot; medium-id &quot;/index.html?match=&quot; (:id category))
                               {:tag :span
                                :attrs {:title (:name medium)}
                                :content (:name medium)}))
                        (span &quot;hitlist_stats&quot;
                              (strong (stats-str-fn score rel-score)))]
                       color
                       rel-score))))]
    (div &quot;hitlist&quot;
         [(olist (map item-gen matchlist))])))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.html" name="distillery.view.html"><h1 class="project-name">distillery.view.html</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.html
  (:require [clojure.pprint :refer (pprint)])
  (:require [clojure.java.io :refer (resource)])
  (:require [net.cgrand.enlive-html :refer (html-resource transform content emit*)])
  (:require [mastersign.html :refer :all])
  (:require [mastersign.trace :refer :all])
  (:require [distillery.text :refer [txt]]))</pre></td></tr><tr><td class="docs"><p>Loads a html template from the 'view' folder by its name without extension.</p>
</td><td class="codes"><pre class="brush: clojure">(defn template
  [name]
  (let [path (str &quot;distillery/view/&quot; name &quot;.html&quot;)]
    (html-resource path)))</pre></td></tr><tr><td class="docs"><p>Generates the title for a page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn build-title
  [{:keys [job-name] :as args} title]
  (if title
    (str job-name &quot; - &quot; title)
    job-name))</pre></td></tr><tr><td class="docs"><p>Builds a menu structure from a menu title and a sequence of label/url pairs.</p>
</td><td class="codes"><pre class="brush: clojure">(defn menu
  [items &amp; {:keys [title]}]
  (let [menu-item (fn [[label url]] (list-item (link url label)))]
    [(if title
       {:tag :div
        :attrs {:class &quot;menu-title&quot;}
        :content title}
       nil)
     {:tag :ul
      :content (-&gt;&gt; items
                    (filter #(not (nil? %)))
                    (map menu-item))}]))</pre></td></tr><tr><td class="docs"><p>Builds the block structure for an inner page.
   Inner pages can be shown without loading content from the server.</p>
</td><td class="codes"><pre class="brush: clojure">(defn innerpage
  [id title active content]
  {:tag :article
   :attrs {:id id
           :class &quot;innerpage&quot;
           :style (str &quot;display: &quot; (if active &quot;inherit&quot; &quot;none&quot;))
           :data-start (str active)}
   :content [(headline 3 title)
             (div &quot;innerpage&quot; content)]})</pre></td></tr><tr><td class="docs"><p>Builds a bar as part of a diagram.</p>
</td><td class="codes"><pre class="brush: clojure">(defn bar
  ([text color v]
   (bar text color v (+ 0.5 (* 0.5 v))))
  ([text [r g b] v1 v2]
   (let [iv (int (* 100 v1))
         c (str &quot;rgba(&quot; (int (* 255 r)) &quot;,&quot; (int (* 255 g)) &quot;,&quot; (int (* 255 b)) &quot;,&quot; (float v2) &quot;)&quot;)]
     (div &quot;bar&quot;
          [(div &quot;bar_text&quot; text)
           (div &quot;bar_client&quot;
                {:tag :div
                 :attrs {:class &quot;bar_beam&quot;
                         :style (str &quot;width:&quot; iv &quot;%; background-color: &quot; c &quot;;&quot;)}})]))))</pre></td></tr><tr><td class="docs"><p>Builds an HTML debug message element with a pretty printed version of the given object.
  Writes a debug message to the trace as a side effect.</p>
</td><td class="codes"><pre class="brush: clojure">(defn DEBUG
  [x]
  (let [w (java.io.StringWriter.)]
    (pprint x w)
    (let [txt (.toString w)]
      (trace-message &quot;DEBUG:\n&quot; txt)
      {:tag :pre
       :content [{:tag :strong :content [(txt :DEBUG) &quot;\n&quot;] }
                 {:tag :code
                  :content [txt]}]})))</pre></td></tr><tr><td class="docs"><p>Builds a highly visible HTML todo message.
  Writes the todo message to the trace as a side effect.</p>
</td><td class="codes"><pre class="brush: clojure">(defn TODO
  [text]
  (trace-message &quot;TODO: &quot; text)
  {:tag :div :attrs {:class &quot;todo&quot;} :content text})</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.index" name="distillery.view.index"><h1 class="project-name">distillery.view.index</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.index
  (:require [net.cgrand.enlive-html :as eh])
  (:require [mastersign.html :refer :all])
  (:require [mastersign.files :refer :all])
  (:require [distillery.data :refer [key-comp]])
  (:require [distillery.text :refer [txt]])
  (:require [distillery.config :as cfg])
  (:require [distillery.view.html :refer :all])
  (:require [distillery.view.glossary :as glossary])
  (:require [distillery.view.cloud :as cloud])
  (:require [distillery.view.hitlist :as hitlist])
  (:require [distillery.view.match :as match]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-hitlist
  [{:keys [words configuration] :as args}]
  (hitlist/render-occurrence-hitlist
   (vals words)
   :occurrences
   configuration
   :main-cloud))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-main-overview
  [{:keys [job-description media categories words] :as args}]
  (innerpage &quot;overview&quot; (txt :main-overview-h) true
             [(paragraph &quot;explanation&quot; (txt :main-overview-d))
              (headline 4 (txt :main-overview-description-h))
              (paragraph job-description)
              (headline 4 (txt :main-overview-content-h))
              (ulist &quot;main_statistic&quot;
                     [(list-item (str (txt :main-overview-media) (count media)))
                      (list-item (str (txt :main-overview-categories) (count categories)))
                      (list-item (str (txt :main-overview-words) (count words)))])
              (headline 4 (txt :main-overview-hitlist-h))
              (paragraph &quot;explanation&quot; (txt :main-overview-hitlist-d))
              (render-hitlist args)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-main-cloud
  [{:keys [cloud] :as args}]
  (innerpage &quot;cloud&quot; (txt :main-wordcloud-h) false
             [(paragraph &quot;explanation&quot; (txt :main-wordcloud-d))
              (cloud/render-cloud &quot;global&quot; cloud)]))</pre></td></tr><tr><td class="docs"><p>Create the HTML for the word frame.
   The word frame is an empty container to load a word page into.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-main-word-frame
  [args]
  (innerpage &quot;word&quot; (txt :main-word-h) false nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-main-glossary
  [{:keys [pwords] :as args}]
  (innerpage &quot;glossary&quot; (txt :main-glossary-h) false
             [(paragraph &quot;explanation&quot; (txt :main-glossary-d))
              (glossary/render-glossary pwords)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-main-matching-matrix
  [args]
   (innerpage &quot;matrix&quot; (txt :main-matching-matrix-h) false
              [(paragraph &quot;explanation&quot; (txt :main-matching-matrix-d))
               (match/render-match-matrix args)]))</pre></td></tr><tr><td class="docs"><p>Renders the main page for the site.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-main-page
  [{:keys [job-name configuration] :as args}]
  [:title (build-title args nil)
   :secondary-menu [[(txt :main-menu-overview) (jshref &quot;innerpage('overview')&quot;)]
                    (when-not (cfg/value :skip-wordclouds configuration)
                      [(txt :main-menu-wordcloud) (jshref &quot;innerpage('cloud')&quot;)])
                    [(txt :main-menu-matching-matrix) (jshref &quot;innerpage('matrix')&quot;)]
                    [(txt :main-menu-glossary) (jshref &quot;innerpage('glossary')&quot;)]]
   :page
     [(headline 2 &quot;Projekt&quot;)
      (render-main-overview args)
      (render-main-cloud args)
      (render-main-matching-matrix args)
      (render-main-glossary args)
      (render-main-word-frame args)]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-categories-list-item
  [{:keys [id name] :as category}]
  (list-item (link (str &quot;categories/&quot; id &quot;/index.html&quot;) name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-categories-list
  [{:keys [categories] :as args}]
  (let [categories-list (-&gt;&gt; categories
                             (into (sorted-set-by (key-comp :name)))
                             (map render-categories-list-item)
                             (ulist))]
    (innerpage &quot;overview&quot; (txt :categories-overview-h) true
               [(paragraph &quot;explanation&quot; (txt :categories-overview-d))
                categories-list])))</pre></td></tr><tr><td class="docs"><p>Renders the categories main page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-categories-page
  [{:keys [job-name] :as args}]
  [:title (build-title args (txt :categories-title))
   :secondary-menu [[(txt :categories-menu-overview) (jshref &quot;innerpage('overview')&quot;)]]
   :page
     [(headline 2 (txt :categories-h))
      (render-categories-list args)]])</pre></td></tr><tr><td class="docs"><p>Renders a medium link as list item.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-media-list-item
  [{:keys [id name] :as medium}]
  (list-item (link (str &quot;media/&quot; id &quot;/index.html&quot;) name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-media-list
  [{:keys [media] :as args}]
  (let [media-list (-&gt;&gt; media
                        (into (sorted-set-by (key-comp :name)))
                        (map render-media-list-item)
                        (ulist))]
    (innerpage &quot;overview&quot; (txt :media-overview-h) true
               [(paragraph &quot;explanation&quot; (txt :media-overview-d))
                media-list])))</pre></td></tr><tr><td class="docs"><p>Renders the media main page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-media-page
  [{:keys [job-name] :as args}]
  [:title (build-title args (txt :media-title))
   :secondary-menu [[(txt :media-menu-overview) (jshref &quot;innerpage('overview')&quot;)]]
   :page
     [(headline 2 (txt :media-h))
      (render-media-list args)]])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.match" name="distillery.view.match"><h1 class="project-name">distillery.view.match</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.match
  (:require [clojure.string :as string])
  (:require [net.cgrand.enlive-html :as eh])
  (:require [mastersign.html :refer :all])
  (:require [distillery.data :refer [key-comp any?]])
  (:require [distillery.text :refer [txt]])
  (:require [distillery.view.html :refer :all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-category-match-word-list
  [{:keys [medium match max-score max-word-score] :as args}]
  (let [index (:index medium)
        items (-&gt;&gt; (:word-scores match)
                   (sort-by second)
                   reverse
                   (map (fn [[word-id score]]
                          (assoc (get index word-id) :score score)))
                   (map (fn [{:keys [id lexical-form score]}]
                          (list-item [(format &quot;%.4f  &quot; (/ score max-word-score))
                                      (jslink
                                       (str &quot;word('&quot; id &quot;');&quot;)
                                       lexical-form)]))))]
    (div (ulist items))))</pre></td></tr><tr><td class="docs"><p>Renders the include part for the match frame of a category page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-category-match-include
  [{:keys [media category match max-score] :as args}]
  (let [{:keys [medium-id]} match
        medium (first (filter #(= (:id %) medium-id) media))]
    [(paragraph [(str (txt :medium) &quot;: &quot;) (strong (:name medium)) {:tag :br}
                 (str (txt :category) &quot;: &quot;) (strong (:name category))])
     (paragraph (str (txt :match-normalized) (format &quot;%.4f&quot; (/ (:score match) max-score))))
     (paragraph &quot;explanation&quot; (txt :match-d))
     (render-category-match-word-list (assoc args :medium medium))]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-match-matrix-head-cell
  [{:keys [id name] :as category}]
  {:tag :th
   :content [(link (str &quot;categories/&quot; id &quot;/index.html&quot;)
                   name)]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-match-matrix-head-row
  [categories]
  {:tag :tr
   :content (vec (cons
                  {:tag :td :content }
                  (map render-match-matrix-head-cell categories)))})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-match-matrix-row
  [matrix max-score category-ids {:keys [id name] :as medium}]
  {:tag :tr
   :content
   (vec (cons {:tag :th
               :content [{:tag :a
                          :attrs {:href (str &quot;media/&quot; id &quot;/index.html&quot;)
                                  :title name}
                          :content name}]}
              (map
               (fn [category-id]
                 (let [match (get-in matrix [category-id id])
                       score (:score match)
                       medium-max-score (:max-score medium)
                       normalized-score (if (&gt; max-score 0) (/ score max-score) 0)
                       medium-normalized-score (if (&gt; medium-max-score 0) (/ score medium-max-score) 0)]
                   (if match
                     {:tag :td
                      :attrs {:data-medium-id id
                              :data-category-id category-id
                              :style (str &quot;background-color: rgba(234,30,106,&quot; medium-normalized-score &quot;)&quot;)}
                      :content [(link (str &quot;categories/&quot; category-id &quot;/index.html?match=&quot; id)
                                      (format &quot;%.1f%%&quot; (* 100 normalized-score)))]}
                     {:tag :td :content []})))
               category-ids)))})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-match-matrix
  [{:keys [media categories max-score] :as args}]
  (let [matrix (-&gt;&gt; categories
                    (map
                     (fn [category]
                       [(:id category)
                        (-&gt;&gt; media
                             (map
                              (fn [medium]
                                [(:id medium)
                                 (get (:matches medium) (:id category))]))
                             (map
                              (fn [[medium-id match]]
                                [medium-id match]))
                             (apply concat)
                             (apply hash-map))]))
                    (apply concat)
                    (apply hash-map))
        category-ids (map :id categories)]
    {:tag :figure
     :content
     [{:tag :table
       :attrs {:class &quot;match_matrix&quot;}
       :content
       [{:tag :thead
         :content
         [(render-match-matrix-head-row categories)]}
        {:tag :tbody
         :content
         (vec (map (partial render-match-matrix-row matrix max-score category-ids) media))}]}]}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.medium" name="distillery.view.medium"><h1 class="project-name">distillery.view.medium</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.medium
  (:require [clojure.string :as string])
  (:require [net.cgrand.enlive-html :as eh])
  (:require [mastersign.html :refer :all])
  (:require [mastersign.files :refer :all])
  (:require [distillery.config :as cfg])
  (:require [distillery.text :refer [txt]])
  (:require [distillery.view.html :refer :all])
  (:require [distillery.view.cloud :as cloud])
  (:require [distillery.view.transcript :as transcript])
  (:require [distillery.view.glossary :as glossary])
  (:require [distillery.view.hitlist :as hitlist]))</pre></td></tr><tr><td class="docs"><p>Creates the headline for the medium page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-headline
  [{:keys [medium]}]
  (headline 2 (:name medium)))</pre></td></tr><tr><td class="docs"><p>Creates the source element for an audio or video player.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-media-source
  [{:keys [id] :as medium} {:keys [ext mime-type] :as emf}]
  {:tag :source
   :attrs {:src (str (:id medium) ext)
           :type mime-type}})</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the video display box.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-video
  [{:keys [medium]}]
  (let [sources (map
                 (partial render-media-source medium)
                 (:encoded-media-files medium))]
    {:tag :figure
     :attrs {:class &quot;video-box&quot;}
     :content
     [{:tag :video
       :attrs {:id &quot;main_video&quot;
               :controls &quot;controls&quot;
               :preload &quot;auto&quot;
               :width &quot;540&quot;
               :height &quot;360&quot; }
       :content (vec sources)}]}))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the audio player.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-audio
  [{:keys [medium]}]
  (let [sources (map
                 (partial render-media-source medium)
                 (:encoded-media-files medium))]
    {:tag :figure
     :attrs {:class &quot;audio_box&quot;}
     :content
     [{:tag :audio
       :attrs {:id &quot;main_audio&quot;
               :controls &quot;controls&quot;
               :preload &quot;auto&quot;
               :style (str &quot;width: &quot; 540 &quot;px;&quot;)}
       :content (vec sources)}]}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-hitlist
  [{:keys [configuration] :as job} {:keys [id index] :as medium}]
  (hitlist/render-occurrence-hitlist
   (vals index)
   (fn [w] (filter #(= id (:medium-id %)) (:occurrences w)))
   configuration
   :medium-cloud))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the waveform.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-waveform
  [{:keys [output-dir configuration] :as job} {:keys [id] :as medium}]
  (copy-file
   (get-path (:waveform-file medium))
   (get-path output-dir &quot;media&quot; id &quot;waveform.png&quot;))
  (copy-file
   (get-path (:waveform-file-bg medium))
   (get-path output-dir &quot;media&quot; id &quot;waveform2.png&quot;))
  {:tag :figure
   :attrs {:class &quot;waveform_box&quot;}
   :content [{:tag :div
              :attrs {:id &quot;main_waveform&quot;
                      :class &quot;waveform&quot;
                      :style (str
                              &quot;width: &quot;
                              (cfg/value [:waveform :width] configuration)
                              &quot;px; height: &quot;
                              (cfg/value [:waveform :height] configuration)
                              &quot;px;&quot;)
                      :data-duration (:duration medium)}
              :content [{:tag :div
                         :attrs {:class &quot;waveform_bg&quot;
                                 :style (str &quot;background-image: url('waveform2.png'); width: &quot;
                                             (cfg/value [:waveform :width] configuration)
                                             &quot;px; height: &quot;
                                             (cfg/value [:waveform :height] configuration)
                                             &quot;px;&quot;)}}
                        {:tag :div
                         :attrs {:class &quot;waveform_img&quot;
                                 :style (str &quot;background-image: url('waveform.png'); width: &quot;
                                             0
                                             &quot;px; height: &quot;
                                             (cfg/value [:waveform :height] configuration)
                                             &quot;px;&quot;) }}]}]})</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the overview page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-overview
  [{:keys [medium] :as job}]
  (innerpage &quot;overview&quot; (txt :medium-overview-h) true
             [(ulist &quot;medium_statistic&quot;
                     [(list-item (str (txt :medium-overview-duration) (transcript/format-time (:duration medium))))
                      (list-item (str (txt :medium-overview-phrase-count) (:phrase-count medium)))
                      (list-item (str (txt :medium-overview-word-count) (:word-count medium)))
                      (list-item (str (txt :medium-overview-index-size) (count (:index medium))))
                      (list-item (str (txt :medium-overview-mean-confidence) (format &quot;%1.1f%%&quot; (* 100 (:confidence medium)))))])
              (headline 4 (txt :medium-overview-waveform-h))
              (paragraph &quot;explanation&quot; (txt :medium-overview-waveform-d))
              (render-waveform job medium)
              (headline 4 (txt :medium-overview-hitlist-h))
              (paragraph &quot;explanation&quot; (txt :medium-overview-hitlist-d))
              (render-hitlist job medium)]))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the transcript with all phrases.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-medium-transcript
  [{{:keys [results index] :as medium} :medium :as args}]
  (innerpage &quot;transcript&quot; (txt :medium-transcript-h) false
             [(paragraph &quot;explanation&quot; (txt :medium-transcript-d))
              (transcript/render-transcript results :index index)]))</pre></td></tr><tr><td class="docs"><p>Create the HTML for the medium glossary.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-medium-glossary
  [{{:keys [pindex] :as medium} :medium :as args}]
  (innerpage &quot;glossary&quot; (txt :medium-glossary-h) false
             [(paragraph &quot;explanation&quot; (txt :medium-glossary-d))
              (glossary/render-glossary pindex)]))</pre></td></tr><tr><td class="docs"><p>Create the HTML for the medium word cloud.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-cloud
  [{{:keys [id cloud] :as medium} :medium :as args}]
  (innerpage &quot;cloud&quot; (txt :medium-wordcloud-h) false
             [(paragraph &quot;explanation&quot; (txt :medium-wordcloud-d))
              (cloud/render-cloud id cloud)]))</pre></td></tr><tr><td class="docs"><p>Create the HTML for the media categories.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-categories
  [{:keys [configuration categories medium max-score] :as args}]
  (let [category-fn (fn [cid] (first (filter #(= cid (:id %)) categories)))]
    (innerpage &quot;categories&quot; (txt :medium-categories-h) false
               [(paragraph &quot;explanation&quot; (txt :medium-categories-d))
                (hitlist/render-category-matchlist
                 medium
                 categories
                 configuration)])))</pre></td></tr><tr><td class="docs"><p>Create the HTML for the word frame.
  The word frame is an empty container to load a medium word page into.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-medium-word-frame
  [args]
  (innerpage &quot;word&quot; (txt :medium-word-h) false nil))</pre></td></tr><tr><td class="docs"><p>Renders the main page for a medium.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-medium-page
  [{:keys [job-name medium categories configuration] :as args}]
  [:base-path &quot;../../&quot;
   :title (build-title args (txt :medium-title))
   :secondary-menu [[(txt :medium-menu-overview) (jshref &quot;innerpage('overview')&quot;)]
                    (when-not (cfg/value :skip-wordclouds configuration)
                      [(txt :medium-menu-wordcloud) (jshref &quot;innerpage('cloud')&quot;)])
                    [(txt :medium-menu-transcript) (jshref &quot;innerpage('transcript')&quot;)]
                    (when (seq categories)
                      [(txt :medium-menu-categories) (jshref &quot;innerpage('categories')&quot;)])
                    [(txt :medium-menu-glossary) (jshref &quot;innerpage('glossary')&quot;)]]
   :page
   [(render-headline args)
    (when (not (cfg/value :skip-media-copy configuration))
      (case (:medium-type medium)
        :video (render-video args)
        :audio (render-audio args)
        nil))
    (render-overview args)
    (render-medium-transcript args)
    (render-medium-glossary args)
    (render-cloud args)
    (render-categories args)
    (render-medium-word-frame args)]])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.transcript" name="distillery.view.transcript"><h1 class="project-name">distillery.view.transcript</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.transcript
  (:require [clojure.string :as string])
  (:require [net.cgrand.enlive-html :as eh])
  (:require [mastersign.html :refer :all])
  (:require [distillery.processing :refer [word-identifier]])
  (:require [distillery.view.html :refer :all]))</pre></td></tr><tr><td class="docs"><p>Creates a pretty time string from total seconds.</p>
</td><td class="codes"><pre class="brush: clojure">(defn format-time
  [seconds]
  (let [h (int (/ seconds (* 60 60)))
        m (int (mod (/ seconds 60) 60))
        s (int (mod seconds 60))]
    (if (&gt; h 0)
      (format &quot;%d:%02d:%02d&quot; h m s)
      (format &quot;%02d:%02d&quot; m s))))</pre></td></tr><tr><td class="docs"><p>Creates a CSS compatible color definition string for a given confidence value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- confidence-color
  [confidence]
  (let [v (int (* (- 1 confidence) 192))]
    (format &quot;#%02X%02X%02X&quot; v v v)))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for a recognized word.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-word
  [{:keys [text lexical-form confidence pronunciation] :as word} &amp; {:keys [index pivot]}]
  (let [id (word-identifier word)
        highlight (= pivot lexical-form)
        color (if highlight &quot;#FF0000&quot; (confidence-color (* confidence confidence)))
        html {:tag :span
              :attrs {:style (str &quot;color:&quot; color)
                      :title pronunciation}
              :content (str text &quot; &quot;)}]
    (if (contains? index id)
      (jslink (str &quot;word('&quot; id &quot;')&quot;) html)
      html)))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for the words of a recognized phrase.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-phrase
  [{:keys [words]} &amp; {:keys [index pivot]}]
  (map #(render-word % :index index :pivot pivot) words))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for a single phrase.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- render-result
  [result &amp; {:keys [index pivot]}]
  (div &quot;phrase&quot; [(span &quot;tc&quot; (jslink (format &quot;medium_jump(%f)&quot; (double (:start result))) (format-time (:start result))))
                 (span &quot;pt&quot; (render-phrase result :index index :pivot pivot))]))</pre></td></tr><tr><td class="docs"><p>Creates the HTML for a sequence of phrases.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-transcript
  [results &amp; {:keys [index pivot]}]
  (div &quot;transcript&quot; (map #(render-result % :index index :pivot pivot) results)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.view.word" name="distillery.view.word"><h1 class="project-name">distillery.view.word</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.view.word
  (:require [clojure.string :as string])
  (:require [net.cgrand.enlive-html :as eh])
  (:require [mastersign.html :refer :all])
  (:require [mastersign.files :refer :all])
  (:require [distillery.data :refer [key-comp any?]])
  (:require [distillery.text :refer [txt]])
  (:require [distillery.view.html :refer :all])
  (:require [distillery.view.transcript :as transcript]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- in-medium-occurrences
  [medium word]
  (filter #(= (:medium-id %) (:id medium)) (:occurrences word)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-word-statistic
  [{:keys [word] :as args}]
  (ulist &quot;word_statistic&quot;
         [(list-item (str (txt :main-word-occurrences) (:occurrence-count word)))
          (list-item (str (txt :main-word-mean-confidence) (format &quot;%1.1f%%&quot; (* 100 (:mean-confidence word)) &quot;%&quot;)))]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-medium-word-statistic
  [{:keys [medium word] :as args}]
  (ulist &quot;word_statistic&quot;
         [(list-item (str (txt :medium-word-occurrences) (count (in-medium-occurrences medium word))))
          (list-item (str (txt :medium-word-mean-confidence) (format &quot;%1.1f%%&quot; (* 100 (:mean-confidence word)) &quot;%&quot;)))]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-category-word-statistic
  [{:keys [category word] :as args}]
  (ulist &quot;word_statistic&quot;
         [(list-item (str (txt :category-word-occurrences) (:occurrence-count word)))]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-medium-word-phrases
  [{:keys [medium word] :as args}]
  (let [occurrences (in-medium-occurrences medium word)
        results (into
                 (sorted-set-by (key-comp :start))
                 (map #(get (:results medium) (:result-no %)) occurrences))]
    (transcript/render-transcript results :index (:index medium) :pivot (:lexical-form word))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-medium-list-item
  [word-id {:keys [id name] :as medium}]
  (list-item (link (str &quot;media/&quot; id &quot;/index.html?word=&quot; word-id) name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-word-medium-list
  [{:keys [word] :as args}]
  (let [word-id (:id word)
        medium-ids (set (map :medium-id (:occurrences word)))
        media (filter #(contains? medium-ids (:id %)) (:media args))]
    (ulist (map (partial render-medium-list-item word-id) media))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-word-category-list
  [{:keys [categories word] :as args}]
  (let [word-id (:id word)
        tmp (map
             (fn [{:keys [matches] :as category}]
                (vals matches))
             categories)
        cats (filter
              (fn [{:keys [matches] :as category}]
                (any?
                 (fn [{:keys [word-scores] :as match}]
                   (contains? word-scores word-id))
                 (vals matches)))
              categories)
        items (map
               (fn [{:keys [id name] :as category}]
                 (list-item
                  (link (str &quot;categories/&quot; id &quot;/index.html?word=&quot; word-id)
                        name)))
               cats)]
    (if (&gt; (count items) 0)
      (ulist items)
      (paragraph (txt :main-word-category-list-empty)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-category-word-medium-list
  [{:keys [media category word max-word-score] :as args}]
  (let [medium-fn (fn [id] (first (filter #(= id (:id %)) media)))
        category-id (:id category)
        word-id (:id word)
        items (-&gt;&gt; (vals (:matches category))
                   (map (fn [{:keys [medium-id word-scores] :as match}]
                          [medium-id
                           (get word-scores word-id)]))
                   (filter #(not (nil? (second %))))
                   (map (fn [[medium-id score]]
                          (let [medium (medium-fn medium-id)]
                            (list-item
                             [(format &quot;%.4f  &quot; (/ score max-word-score))
                              (link (str &quot;../../media/&quot; medium-id &quot;/index.html?word=&quot; word-id)
                                    (:name medium))])))))]
    (if (&gt; (count items) 0)
      (ulist items)
      (paragraph (txt :category-word-medium-list-empty)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-medium-word-category-list
  [{:keys [categories medium word max-word-score] :as args}]
  (let [category-fn (fn [id] (first (filter #(= id (:id %)) categories)))
        medium-id (:id medium)
        word-id (:id word)
        items (-&gt;&gt; (vals (:matches medium))
                   (map (fn [{:keys [category-id word-scores] :as match}]
                          [category-id
                           (get word-scores word-id)]))
                   (filter #(not (nil? (second %))))
                   (map (fn [[category-id score]]
                          (let [category (category-fn category-id)]
                            (list-item
                             [(format &quot;%.4f  &quot; (/ score max-word-score))
                              (link (str &quot;../../categories/&quot; category-id &quot;/index.html?word=&quot; word-id)
                                    (:name category))])))))]
    (if (&gt; (count items) 0)
      (ulist items)
      (paragraph (txt :medium-word-category-list-empty)))))</pre></td></tr><tr><td class="docs"><p>Renders the include part for the word frame.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-word-include
  [{:keys [word] :as args}]
  (let [{:keys [lexical-form pronunciation]} word]
    [(headline 4 &quot;word_headline&quot; [lexical-form (span &quot;pronunciation&quot; pronunciation)])
     (render-word-statistic args)
     (headline 4 (txt :main-word-media-h))
     (paragraph &quot;explanation&quot; (txt :main-word-media-d))
     (render-word-medium-list args)
     (headline 4 (txt :main-word-categories-h))
     (paragraph &quot;explanation&quot; (txt :main-word-categories-d))
     (render-word-category-list args)]))</pre></td></tr><tr><td class="docs"><p>Renders the include part for the word frame of a medium page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-medium-word-include
  [{:keys [word] :as args}]
  (let [{:keys [lexical-form pronunciation]} word]
    [(headline 4 &quot;word_headline&quot; [lexical-form (span &quot;pronunciation&quot; pronunciation)])
     (render-medium-word-statistic args)
     (headline 4 (txt :medium-word-phrases-h))
     (paragraph &quot;explanation&quot; (txt :medium-word-phrases-d))
     (render-medium-word-phrases args)
     (headline 4 (txt :medium-word-categories-h))
     (paragraph &quot;explanation&quot; (txt :medium-word-categories-d))
     (render-medium-word-category-list args)]))</pre></td></tr><tr><td class="docs"><p>Renders the include part for the word frame of a category page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-category-word-include
  [{:keys [word] :as args}]
  (let [{:keys [lexical-form]} word]
    [(headline 4 &quot;word_headline&quot; lexical-form)
     (render-category-word-statistic args)
     (headline 4 (txt :category-word-media-h))
     (paragraph &quot;explanation&quot; (txt :category-word-media-d))
     (render-category-word-medium-list args)]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#distillery.xmlresult" name="distillery.xmlresult"><h1 class="project-name">distillery.xmlresult</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns distillery.xmlresult
  (:import [java.util Locale])
  (:require [clojure.java.io :refer (writer)])
  (:require [clojure.data.xml :as xml]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- tag-list
  [tag-name f xs]
  (let [tags (map f xs)]
    (vec (concat [tag-name {:length (count tags)}] tags))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-invariant
  [fmt &amp; args]
  (String/format Locale/US fmt (to-array args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- category-resource-tag
  [job category resource]
  [:Resource {:type (name (:type resource))} (:url resource)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- category-match-tag
  [job category [medium-id match]]
  [:Match {:medium-id medium-id
           :score (format-invariant &quot;%.6f&quot; (:score match))}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- category-tag
  [job category]
  [:Category {:id (:id category)}
   [:Name {} (:name category)]
   (tag-list :MatchList
             (partial category-match-tag job category)
             (filter
              (fn [[id match]] (&gt;= (:score match) (get-in job [:configuration :min-match-score])))
              (:matches category)))
   (tag-list :ResourceList
             (partial category-resource-tag job category)
             (:resources category))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- medium-match-tag
  [job medium [category-id match]]
  [:Match {:category-id category-id
           :score (format-invariant &quot;%.6f&quot; (:score match))}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- recognized-word
  [job phrase word]
  [:Word {:no (:no word)
          :confidence (:confidence word)}
   (:text word)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- recognized-phrase
  [job result]
  [:Phrase {:no (:no result)
            :start (:start result)
            :duration (:duration result)
            :confidence (:confidence result)}
   [:Text {} (:text result)]
   ;(tag-list :WordList
   ;          (partial recognized-word job result)
   ;          (:words result))
   ])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- speech-recognition-tag
  [job medium]
  [:SpeechRecognition {:profile (:recognition-profile medium)
                       :profile-name (:recognition-profile-name medium)}
   (tag-list :PhraseList
             (partial recognized-phrase job)
             (:results medium))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- medium-tag
  [job medium]
  [:Media {:id (:id medium)}
   [:Name {} (:name medium)]
   (tag-list :MatchList
             (partial medium-match-tag job medium)
             (filter
              (fn [[id match]] (&gt;= (:score match) (get-in job [:configuration :min-match-score])))
              (:matches medium)))
   [:Source {} (:medium-file medium)]
   (speech-recognition-tag job medium)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- occurrence-tag
  [job word {:keys [medium-id result-no word-no] :as occurrence}]
  (let [medium (first (filter #(= medium-id (:id %)) (:media job)))
        phrase-start (get-in medium [:results result-no :start])]
    [:Occurrence {:medium medium-id
                  :phrase result-no
                  :no word-no
                  :phrase-start (format-invariant &quot;%.2f&quot; (double phrase-start))}]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- word-tag
  [job {:keys [lexical-form pronunciation occurrence-count occurrences] :as word}]
  [:Word {:lexical-form lexical-form
          :pronunciation pronunciation}
   (tag-list :OccurrenceList
             (partial occurrence-tag job word)
             occurrences)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- job-result-tags
  [job]
  (xml/sexp-as-element
   [:MediaCategorizerResults {:tool-version (:media-categorizer-version job)}
    [:JobInfo {}
     [:Name {} (:job-name job)]
     [:Description {} (:job-description job)]]
    (tag-list :CategoryList
              (partial category-tag job)
              (:categories job))
    (tag-list :MediaList
              (partial medium-tag job)
              (:media job))
    (tag-list :Glossary
              (partial word-tag job)
              (map val (:words job)))]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn save-result
  [path job]
  (let [tags (job-result-tags job)]
    (with-open [w (writer path)]
      (xml/indent tags w))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#mastersign.drawing" name="mastersign.drawing"><h1 class="project-name">mastersign.drawing</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns mastersign.drawing
  (:import [java.awt Color Font Graphics2D])
  (:import [java.awt.geom
            AffineTransform
            Point2D Point2D$Float
            Rectangle2D Rectangle2D$Float])
  (:require [mastersign.geom :refer :all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def default-font-size 16)
(def default-font-style Font/PLAIN)
(def default-font (Font. Font/SANS_SERIF default-font-style default-font-size))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn color
  ([v] (Color. (float v) (float v) (float v) (float 1)))
  ([r g b] (Color. (float r) (float g) (float b) (float 1)))
  ([r g b a] (Color. (float r) (float g) (float b) (float a))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- font-family-name
  [family]
  (case family
    :dialog Font/DIALOG
    :dialog-input Font/DIALOG_INPUT
    :mono Font/MONOSPACED
    :serif Font/SERIF
    :sans-serif Font/SANS_SERIF
    family))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ^:const font-styles
  {:plain Font/PLAIN
   :bold Font/BOLD
   :italic Font/ITALIC})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- font-style
  [styles]
  (reduce
   (fn [r s] (+ r (get font-styles s)))
   Font/PLAIN
   styles))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn font
  ([]
   (font :dialog))
  ([family]
   (font family (float 14)))
  ([family size]
   (font family size :plain))
  ([family size &amp; styles]
   (Font. (font-family-name family) (font-style styles) (float size))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn draw-dot
  ([^Graphics2D g ^Point2D$Float p &amp; {color :color
           :or {color Color/RED}}]
  (doto g
    (.setColor color)
    (.fill (ellipse (- (.x p) 1) (- (.y p) 1) 2 2)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn draw-dots
  [^Graphics2D g ps o &amp; {color :color
                 :or {color Color/RED}}]
  (doseq [p (map #(translate-point % o) ps)] (draw-dot g p :color color)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn draw-rect
  [^Graphics2D g ^Rectangle2D$Float r &amp; {color :color
          :or {color Color/BLUE}}]
  (doto g
    (.setColor color)
    (.draw r)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fill-rect
  [^Graphics2D g ^Rectangle2D$Float r &amp; {color :color
          :or {color Color/GREEN}}]
  (doto g
    (.setColor color)
    (.fill r)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn draw-shape
  [^Graphics2D g s &amp; {color :color
          :or {color Color/ORANGE}}]
  (doto g
    (.setColor color)
    (.draw s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fill-shape
  [^Graphics2D g s &amp; {color :color
          :or {color Color/YELLOW}}]
  (doto g
    (.setColor color)
    (.fill s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn draw-string
  [^Graphics2D g ^Point2D$Float p ^String text &amp; {font :font
               color :color
               :or {font default-font
                    color Color/BLACK}}]
  (doto g
    (.setColor color)
    (.setFont font)
    (.drawString text (.x p) (.y p))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn string-centered-offset
  [^Graphics2D g ^Font font ^String text]
  (let [gv (.createGlyphVector font (.getFontRenderContext g) text)
        r (.getVisualBounds gv)
        ^Point2D$Float c (rect-center r)]
     (point (- (.x c)) (- (.y c)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn string-centered-bounds
  ([^Graphics2D g font text]
   (string-centered-bounds g font text 0 0))
  ([^Graphics2D g font text ^Point2D$Float p]
   (string-centered-bounds g font text (.x p) (.y p)))
  ([^Graphics2D g ^Font font ^String text x y]
   (let [gv (.createGlyphVector font (.getFontRenderContext g) text)
         ^Rectangle2D$Float r (.getVisualBounds gv)
         ^Point2D$Float c (rect-center r)]
     (rectangle (- (+ x (.x r)) (.x c)) (- (+ y (.y r)) (.y c)) (.width r) (.height r)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn string-centered-glyphbounds
  ([^Graphics2D g font text]
   (string-centered-glyphbounds g font text 0 0))
  ([^Graphics2D g font text ^Point2D$Float p]
   (string-centered-glyphbounds g font text (.x p) (.y p)))
  ([^Graphics2D g ^Font font ^String text x y]
  (let [frc (.getFontRenderContext g)
        gv (.createGlyphVector font frc text)
        r (.getVisualBounds gv)
        ^Point2D$Float c (rect-center r)
        glyphbounds (map
                     #(.getBounds2D (.getGlyphOutline gv % (- x (.x c)) (- y (.y c))))
                     (range (.getNumGlyphs gv)))]
    (vec glyphbounds))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn string-centered-outline
  ([^Graphics2D g font text]
   (string-centered-outline g font text 0 0))
  ([^Graphics2D g font text ^Point2D$Float p]
   (string-centered-outline g font text (.x p) (.y p)))
  ([^Graphics2D g ^Font font ^String text x y]
   (let [frc (.getFontRenderContext g)
         gv (.createGlyphVector font frc text)
         r (.getVisualBounds gv)
         ^Point2D$Float c (rect-center r)]
     (.getOutline gv (- x (.x c)) (- y (.y c))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn draw-string-centered
  [^Graphics2D g ^String text ^Point2D$Float p &amp; {font :font
               color :color
               rotation :rotation
               :or {font default-font,
                    color Color/BLACK
                    rotation 0}}]
  (let [^Point2D$Float offset (string-centered-offset g font text)
        x (.x p)
        y (.y p)
        transform (AffineTransform/getRotateInstance (* rotation (/ Math/PI 180)) x y)]
    (doto g
        (.setColor color)
        (.setFont font)
        (.setTransform transform)
        (.drawString text
                     (float (+ (.x p) (.x offset)))
                     (float (+ (.y p) (.y offset))))
        (.setTransform (AffineTransform.)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#mastersign.files" name="mastersign.files"><h1 class="project-name">mastersign.files</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns mastersign.files
  (:import [java.net URL])
  (:import [java.nio.file Paths Path Files CopyOption StandardCopyOption LinkOption])
  (:import [java.nio.file.attribute FileAttribute]))</pre></td></tr><tr><td class="docs"><p>Returs a <code>java.nio.file.Path</code> object for the given path.</p>

<p>  The path is specified by a base <code>path</code> and optional
  a number of additional <code>parts</code>.
  The base path can be a string or a <code>java.net.URL</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-path
  ^java.nio.file.Path
  [path &amp; parts]
  (if (instance? URL path)
    (Paths/get (.toURI ^URL path))
    (Paths/get ^String path (if parts (into-array parts) (make-array String 0)))))</pre></td></tr><tr><td class="docs"><p>Returns a string with the specified path.</p>

<p>  Uses the same interface like <code>get-path</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn combine-path
  ^String [path &amp; parts]
  (.toString ^Path (apply get-path (cons path parts))))</pre></td></tr><tr><td class="docs"><p>Returns a string with the path of the parent of the specified file / directory.</p>

<p>  Uses the same interface like <code>get-path</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn dir-name
  ^String [path &amp; parts]
  (.toString ^Path (.getParent ^Path (apply get-path (cons path parts)))))</pre></td></tr><tr><td class="docs"><p>Returns a string with the name of the specified file / directory.</p>

<p>  Uses the same interface like <code>get-path</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn file-name
  ^String [path &amp; parts]
  (.toString ^Path (.getFileName ^Path (apply get-path (cons path parts)))))</pre></td></tr><tr><td class="docs"><p>Returns the extension of the given file name or nil if the name has no extension.</p>

<p>  Uses the same interface like <code>get-path</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn file-name-ext
  ^String [path &amp; parts]
  (let [n (apply file-name path parts)]
    (re-find #&quot;\.[^\.]+$&quot; n)))</pre></td></tr><tr><td class="docs"><p>Copies a file from a given <code>source</code> path to the <code>target</code> path.</p>

<p>  The source and target path need to be <code>java.nio.file.Path</code> objects.</p>
</td><td class="codes"><pre class="brush: clojure">(defn copy-file
  [^Path source ^Path target]
  (Files/copy source target (into-array CopyOption [StandardCopyOption/REPLACE_EXISTING])))</pre></td></tr><tr><td class="docs"><p>Creates a directory including all non existing parent directories.</p>

<p>  Uses the same interface like <code>get-path</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-dir
  [path &amp; parts]
  (let [path (apply get-path (cons path parts))]
    (Files/createDirectories path (make-array FileAttribute 0))))</pre></td></tr><tr><td class="docs"><p>Checks if the specified file exists.</p>

<p>  Uses the same interface like <code>get-path</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn file-exists?
  [path &amp; parts]
  (let [path (apply get-path (cons path parts))]
    (Files/exists path (make-array LinkOption 0))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#mastersign.geom" name="mastersign.geom"><h1 class="project-name">mastersign.geom</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns mastersign.geom
  (:import [java.awt.geom
            AffineTransform
            Area
            Rectangle2D Rectangle2D$Float
            Point2D Point2D$Float
            Ellipse2D Ellipse2D$Float]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn point
  ([] (point 0 0))
  (^Point2D$Float
   [x y] (Point2D$Float. (float x) (float y))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn polar-point
  [r a]
  (point (* r (Math/cos a)) (- (* r (Math/sin a)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rectangle
  ([] (rectangle 0 0 0 0))
  (^Rectangle2D$Float
   [x y w h] (Rectangle2D$Float. (float x) (float y) (float w) (float h)))
  ([^Point2D$Float p w h] (rectangle (.x p) (.y p) w h)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ellipse
  ([] (ellipse 0 0 0 0))
  (^Ellipse2D$Float
   [x y w h] (Ellipse2D$Float. (float x) (float y) (float w) (float h)))
  ([^Point2D$Float p w h] (ellipse (.x p) (.y p) w h)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rect-center
  [^Rectangle2D$Float r]
  (point (+ (.x r) (/ (.width r) 2.0))
         (+ (.y r) (/ (.height r) 2.0))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn grow-rect
  [^Rectangle2D$Float r d]
  (rectangle (- (.x r) d) (- (.y r) d) (+ (.width r) d d) (+ (.height r) d d)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn translate-point
  ([^Point2D$Float p ^Point2D$Float o]
   (translate-point p (.x o) (.y o)))
  ([^Point2D$Float p x y]
   (point (+ (.x p) x) (+ (.y p) y))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn translate-rect
  ([^Rectangle2D$Float r ^Point2D$Float o]
   (translate-rect r (.x o) (.y o)))
  ([^Rectangle2D$Float r x y]
   (rectangle (+ (.x r) x) (+ (.y r) y) (.width r) (.height r))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn translate-ellipse
  ([^Ellipse2D$Float e ^Point2D$Float o]
   (translate-ellipse e (.x o) (.y o)))
  ([^Ellipse2D$Float e x y]
   (ellipse (+ (.x e) x) (+ (.y e) y) (.width e) (.height e))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn area
  (^Area
   [] (Area.))
  (^Area
   [s] (Area. s))
  (^Area
   [s &amp; shapes]
   (let [*a* (Area. s)]
     (doseq [s shapes]
       (.add *a* (Area. s)))
     *a*)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn translate-area
  ([area ^Point2D$Float o]
   (translate-area area (.x o) (.y o)))
  (^Area
   [^Area area x y]
   (.createTransformedArea
    area
    (AffineTransform/getTranslateInstance (double x) (double y)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#mastersign.html" name="mastersign.html"><h1 class="project-name">mastersign.html</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns mastersign.html
  (:require [net.cgrand.enlive-html :refer (html-resource transform content emit*)]))</pre></td></tr><tr><td class="docs"><p>Transforms the html model into a sequence of strings.</p>
</td><td class="codes"><pre class="brush: clojure">(defn emit-view
  [view]
  (apply str (emit* view)))</pre></td></tr><tr><td class="docs"><p>Converts a HTML description map, converts it to a HTML string and writes it to the given file path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn save-page
  [path page]
  (spit path (emit-view page) :encoding &quot;UTF-8&quot;))</pre></td></tr><tr><td class="docs"><p>Creates a function to replace the content of a specified html element.</p>
</td><td class="codes"><pre class="brush: clojure">(defn replacer
  [selector &amp; {:keys [data-transform]}]
  (fn [src data]
    (let [data (if data-transform (data-transform data) data)]
      (transform src selector (content data)))))</pre></td></tr><tr><td class="docs"><p>Creates a function to transform an attribute of a html element with a given function.</p>
</td><td class="codes"><pre class="brush: clojure">(defn attr-transformer
  [attr f]
  (fn [element]
    (if (contains? (:attrs element) attr)
      (update-in element [:attrs attr] f)
      element)))</pre></td></tr><tr><td class="docs"><p>Makes the given data compatible with the <code>:content</code> slot of an HTML element map.
  If it is ...
      * a string or a vector: it is return unaltered.
      * another HTML element map: it is wrapped into a vector.
      * an arbitrary collection: it is flattened and converted into a vector.
      * somthing else: it is converted into a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn safe-content
  [content]
  (if (or (string? content) (vector? content))
    content
    (if (and (map? content) (:tag content))
      [content]
      (if (coll? content)
        (vec (flatten content))
        (str content)))))</pre></td></tr><tr><td class="docs"><p>Wrappes the given content into a paragraph.</p>
</td><td class="codes"><pre class="brush: clojure">(defn paragraph
  ([content]
  {:tag :p :content (safe-content content)})
  ([css-class content]
  (assoc-in (paragraph content) [:attrs :class] css-class)))</pre></td></tr><tr><td class="docs"><p>Wrappes the given content into a headline. Headline levels from 1 to 8 are supported.</p>
</td><td class="codes"><pre class="brush: clojure">(defn headline
  ([level content]
  (let [head-sym
        (cond
          (= level 1) :h1
          (= level 2) :h2
          (= level 3) :h3
          (= level 4) :h4
          (= level 5) :h5
          (= level 6) :h6
          (= level 7) :h7
          (= level 8) :h8)]
    {:tag head-sym :content (safe-content content)}))
  ([level css-class content]
   (assoc-in (headline level content) [:attrs :class] css-class)))</pre></td></tr><tr><td class="docs"><p>Wrappes the given text into a pre element.</p>
</td><td class="codes"><pre class="brush: clojure">(defn preformatted
  [text]
  {:tag :pre :content text})</pre></td></tr><tr><td class="docs"><p>Wrappes the given text into a code and pre element.</p>
</td><td class="codes"><pre class="brush: clojure">(defn code
  [text]
  {:tag :code :content [{:tag :pre :content text}]})</pre></td></tr><tr><td class="docs"><p>Wrappes the content into an emphasizing element.</p>
</td><td class="codes"><pre class="brush: clojure">(defn emph
  [content]
  {:tag :em :content (safe-content content)})</pre></td></tr><tr><td class="docs"><p>Wrappes the content int a strong emphasizing element.</p>
</td><td class="codes"><pre class="brush: clojure">(defn strong
  [content]
  {:tag :strong :content (safe-content content)})</pre></td></tr><tr><td class="docs"><p>Creates a div container with a given CSS class and some content.</p>
</td><td class="codes"><pre class="brush: clojure">(defn div
  ([content]
   {:tag :div :content (safe-content content)})
  ([css-class content]
   (assoc-in (div content) [:attrs :class] css-class)))</pre></td></tr><tr><td class="docs"><p>Creates a span container with a given CSS class and some text.</p>
</td><td class="codes"><pre class="brush: clojure">(defn span
  ([content]
   {:tag :span :content (safe-content content)})
  ([css-class content]
   (assoc-in (span content) [:attrs :class] css-class)))</pre></td></tr><tr><td class="docs"><p>Creates a list item.</p>
</td><td class="codes"><pre class="brush: clojure">(defn list-item
  ([content]
   {:tag :li :content (safe-content content)})
  ([css-class content]
   (assoc-in (list-item content) [:attrs :class] css-class)))</pre></td></tr><tr><td class="docs"><p>Creates an unordered list with a given CSS class and a sequence of list items.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ulist
  ([items]
   {:tag :ul :content (vec items)})
  ([css-class items]
   (assoc-in (ulist items) [:attrs :class] css-class)))</pre></td></tr><tr><td class="docs"><p>Creates an ordered list with a given CSS class and a sequence of list items.</p>
</td><td class="codes"><pre class="brush: clojure">(defn olist
  ([items]
   {:tag :ol :content (vec items)})
  ([css-class items]
   (assoc-in (olist content) [:attrs :class] css-class)))</pre></td></tr><tr><td class="docs"><p>Create a link tag with the given URL an optional target and some content.</p>
</td><td class="codes"><pre class="brush: clojure">(defn link
  ([url content]
   {:tag :a :attrs {:href url} :content (safe-content content)})
  ([url target content]
   (assoc-in (link url content) [:attrs :target] target)))</pre></td></tr><tr><td class="docs"><p>Creates a script tag for JavaScript code.</p>
</td><td class="codes"><pre class="brush: clojure">(defn jscript
  [js]
  {:tag :script
   :attrs {:type &quot;text/javascript&quot;}
   :content [js]})</pre></td></tr><tr><td class="docs"><p>Creates a URI referencing a JavaScript call.</p>
</td><td class="codes"><pre class="brush: clojure">(defn jshref
  [js]
  (str &quot;javascript:&quot; js ))</pre></td></tr><tr><td class="docs"><p>Creates a link tag with the given javascript command and some content.
   The javascript code must not contain double quotes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn jslink
  [js content]
  {:tag :a :attrs {:href (jshref js)} :content (safe-content content)})</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#mastersign.imaging" name="mastersign.imaging"><h1 class="project-name">mastersign.imaging</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns mastersign.imaging
  (:import [java.io File])
  (:import [java.awt Color Graphics Graphics2D Image])
  (:import [java.awt.image BufferedImage])
  (:import [javax.swing JFrame JPanel])
  (:import [javax.imageio ImageIO]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn image
  ^BufferedImage [w h]
  (BufferedImage. w h BufferedImage/TYPE_INT_ARGB))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-image
  [w h f]
  (let [^BufferedImage img (image w h)
        ^Graphics g (.createGraphics img)]
    (f g w h)
    (.dispose g)
    img))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn save-image
  [^BufferedImage img ^String path]
  (ImageIO/write img &quot;png&quot; (File. path)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn show-image
  [^Image img]
  (let [w (.getWidth img nil)
        h (.getHeight img nil)
        fw (+ w 32)
        fh (+ h 56)
        frame (JFrame. &quot;Image Display&quot;)
        panel (proxy [JPanel] []
                (paintComponent
                 [^Graphics2D g]
                 (doto g
                   (.setColor (Color. 240 245 255))
                   (.fillRect 0 0 fw fh)
                   (.setColor (Color/BLACK))
                   (.drawRect 7 7 (inc w) (inc h))
                   (.drawImage img 8 8 w h this))))]
    (doto frame
      (.setDefaultCloseOperation JFrame/DISPOSE_ON_CLOSE)
      (.setSize fw fh)
      (.setContentPane panel)
      (.setVisible true))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#mastersign.trace" name="mastersign.trace"><h1 class="project-name">mastersign.trace</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns mastersign.trace)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private trace-agent (agent nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trace-message
  [&amp; msg]
  (let [text (apply str msg)]
  (send-off trace-agent
        (fn [state] (println (str &quot;# &quot; text))))
  text))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro trace-block
  [msg &amp; body]
  `(do
     (trace-message (str &quot;BEGIN &quot; ~msg &quot;...&quot;))
     (let [start# (System/nanoTime)
           result# (do ~@body)
           end# (/ (- (System/nanoTime) start#) 1000000.0)]
       (trace-message (str &quot;END   &quot; ~msg &quot; after &quot; end# &quot; msecs&quot;))
       result#)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#mastersign.wordcloud" name="mastersign.wordcloud"><h1 class="project-name">mastersign.wordcloud</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns mastersign.wordcloud
  (:import [java.awt Graphics Graphics2D Color RenderingHints Font])
  (:import [java.awt.image BufferedImage])
  (:import [java.awt.geom Area
            Rectangle2D Rectangle2D$Float
            Point2D Point2D$Float
            Ellipse2D Ellipse2D$Float])
  (:require [clojure.pprint :refer (pprint)])
  (:require [mastersign.geom :refer :all])
  (:require [mastersign.drawing :refer :all])
  (:require [mastersign.imaging :refer :all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn default-color-fn
  [value]
  (let [n (float 0.4)
        v1 (float value)
        v2 (float (- 1.0 value))]
  (Color. v1 n v2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def default-args
  {:width 600
   :height 300
   :precision 0.4
   :font (Font. &quot;Calibri&quot; Font/BOLD (float 30))
   :min-font-size 14
   :max-font-size 80
   :max-test-radius 350
   :order-priority 0.7
   :padding 4
   :debug false
   :shape-mode :glyph-box ; :word-box, :glyph-box
   :allow-rotation true
   :final-refine true
   :order-mode :value1 ; :id, :text, :value1, :value2
   :background-color (Color. 0 0 0 0)
   :color-fn #'default-color-fn
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- calc-font-size
  [{:keys [min-font-size max-font-size]} v]
  (double (+ min-font-size (* (- max-font-size min-font-size) v v))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-font
  [{:keys [^Font font] :as args} v]
  (.deriveFont font ^double (calc-font-size args v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-color
  [{:keys [color-fn]} v]
  (color-fn v))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- build-word-info
  [g args [id text v1 v2]]
  (let [font* (get-font args v1)
        color (get-color args v2)]
    {:id id
     :text text
     :v1 v1
     :v2 v2
     :font font*
     :color color
     :word-bounds (string-centered-bounds g font* text)
     :glyph-bounds (string-centered-glyphbounds g font* text)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn build-word-infos
  [word-data args]
  (let [img (image 1 1)
        graphics (.createGraphics img)
        word-data* (case (:order-mode args)
                       :id (sort-by first word-data)
                       :text (sort-by second word-data)
                       :value2 (reverse (sort-by #(nth % 3) word-data))
                       (reverse (sort-by #(nth % 2) word-data)))
        word-infos (doall (map (partial build-word-info graphics args) word-data*))]
    (.dispose graphics)
    word-infos))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- setup-graphics-context
  [^Graphics2D g]
  (doto g
    (.setRenderingHint RenderingHints/KEY_ANTIALIASING RenderingHints/VALUE_ANTIALIAS_ON)
    (.setRenderingHint RenderingHints/KEY_TEXT_ANTIALIASING RenderingHints/VALUE_TEXT_ANTIALIAS_ON)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- lazy-numbers
   ([] (lazy-numbers 0))
   ([n] (lazy-seq (cons n (lazy-numbers (inc n))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- priority-angle
  [^String text]
  (let [clean-DE (fn [c] (case c \Ä \A \Ö \O \Ü \U \ß \S c))
        c (clean-DE (first (.toUpperCase text)))
        n (int c)
        s (- (if (or (&lt; n 64) (&gt; n 90)) 64 n) 65)]
    (if (&lt; s 14)
      (- Math/PI (/ Math/PI 28) (* (/ Math/PI 14) s))
      (+ Math/PI (/ Math/PI 26) (* (/ Math/PI 12) (- s 14))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ring-step
  [r prec]
  (/ 2.0 (+ 4 (* prec prec (* Math/PI r)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- scale-radius
  [priority r a]
  (let [base (* r (- 1.0 priority))
        a* (* Math/PI (Math/sqrt a))]
    (+ base (* (- r base) (+ (* (Math/cos a*) 0.5) 0.5)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ring-angles
  [precision priority r a]
  (lazy-seq (cons
             a
             (ring-angles precision priority r
                          (+ a (ring-step (scale-radius priority r a) precision))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- test-ring
  [r precision pa priority]
  (cons
   (polar-point r pa)
   (apply concat (map
             (fn [a]
               (let [sr (scale-radius priority r a)
                     a* (* Math/PI a)]
                 [(polar-point sr (+ pa a*))
                  (polar-point sr (- pa a*))]))
             (take-while #(&lt; % 1.0) (ring-angles precision priority r 0))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- test-sequence
  [{:keys [width height precision max-font-size max-test-radius order-priority] :as args} {:keys [text] :as word-info}]
  (let [imprecision (* (- 1.0 precision) (- 1.0 precision))
        radii (take-while
                  #(&lt; (scale-radius order-priority % 1) max-test-radius)
                  (map #(* (+ 1 (* imprecision max-font-size 0.5)) %) (lazy-numbers 1)))
        pa (if (&gt; order-priority 0.0)
             (priority-angle text)
             (rand (* Math/PI 2)))
        rings (map #(test-ring % precision pa order-priority) radii)
        boundaries (rectangle (- (/ width 2.0)) (- (/ height 2.0)) width height)
        reject-pred (fn [^Point2D$Float p] (.contains boundaries (.x p) (.y p)))]
    (filter reject-pred (cons (point) (apply concat rings)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- rotate-rect
  [^Rectangle2D$Float r ^Point2D$Float c ^double a]
  (if (== a 0)
    r
    (let [x (.x r)
          y (.y r)
          w (.width r)
          h (.height r)
          cx (.x c)
          cy (.y c)
          dx (- x cx)
          dy (- y cy)]
      (case a
        90.0 (rectangle (- cx dy h) (+ cy dx) h w)
        180.0 (rectangle (- cx dx w) (- cy dy h) w h)
        270.0 (rectangle (+ cx dy) (- cy dx w) h w)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-word-rects
  [{:keys [shape-mode padding]} word-info pos rotation use-padding]
  (let [rects (case shape-mode
                :word-box [(translate-rect (:word-bounds word-info) pos)]
                :glyph-box (map #(translate-rect % pos) (:glyph-bounds word-info)))
        rects (if use-padding
                (map #(grow-rect % padding) rects)
                rects)
        rects (map #(rotate-rect % pos rotation) rects)]
    rects))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- check-position
  [args ^Area test-area ^Area boundaries word-info pos rotation]
  (let [rects (get-word-rects args word-info pos rotation false)]
    (if (and
         (every? #(.contains boundaries ^Rectangle2D$Float %) rects)
         (every? #(not (.intersects test-area %)) rects))
      [pos rotation]
      nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- recur-seq
  [f args]
  (let [args* (apply f args)]
    (if (nil? args*)
      [args]
      (cons
       args
       (recur-seq f args*)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- approach
  [check-fn ^Point2D$Float ref-pos ^Point2D$Float pos ^double rotation]
  (let [sign #(if (&lt; % 0) -1 1)
        rx (int (.x ref-pos))
        ry (int (.y ref-pos))
        dx (- rx (int (.x pos)))
        dy (- ry (int (.y pos)))
        sx (sign dx)
        sy (sign dy)
        step-fn (fn [^Point2D$Float p ^double r]
                  (let [px (int (.x p))
                        py (int (.y p))
                        x (+ px sx)
                        y (+ py sy)]
                    (or
                     (when (or (and (== sx -1) (&gt; x rx)) (and (== sx 1) (&lt; x rx))) (check-fn (point (+ (.x p) sx) (.y p)) r))
                     (when (or (and (== sy -1) (&gt; y ry)) (and (== sy 1) (&lt; y ry))) (check-fn (point (.x p) (+ (.y p) sy)) r)))))]
    (if (and (== 0 dx) (== 0 dy))
      [pos rotation]
      (last (recur-seq step-fn [pos rotation])))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- find-position
  [{:keys [allow-rotation final-refine] :as args} test-area boundaries point-sequence {:keys [word-bounds] :as word-info}]
  (let [check (partial check-position args test-area boundaries word-info)
        check* (if allow-rotation
               (fn [pos] (or (check pos 0) (check pos 90) (check pos 270)))
               (fn [pos] (check pos 0)))
        [p a] (first (filter #(not (nil? %)) (map check* point-sequence)))]
    (if (and final-refine (not (nil? p)))
      (approach check (point) p a)
      [p a])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- add-word-to-area!
  [args ^Area *area* word-info pos rotation]
  (let [rects (get-word-rects args word-info pos rotation true)]
    (.add *area* (apply area rects))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn build-cloud-info
  [word-infos args]
  (let [{:keys [width height padding]} args
        boundaries (area (rectangle (- (/ width 2)) (- (/ height 2)) width height))
        center (point (/ width 2) (/ height 2))
        *test-area* (area)
        finder (fn [{:keys [text word-bounds] :as word-info}]
                 ;(println (str &quot;Placing &quot; text &quot; ...&quot;))
                 (let [point-sequence (test-sequence args word-info)
                       [hit rotation] (find-position args *test-area* boundaries point-sequence word-info)]
                   (if (nil? hit)
                     nil
                     (do
                       (add-word-to-area! args *test-area* word-info hit rotation)
                       ;(println (str &quot;Found place at &quot; (.x hit) &quot;, &quot; (.y hit)))
                       (assoc word-info
                         :position hit
                         :rotation rotation
                         :rect (translate-rect
                                (rotate-rect word-bounds (point) rotation)
                                (translate-point hit center)))))))]
    {:args args
     :word-infos (take-while #(not (nil? %)) (map finder word-infos))
     :test-area *test-area*}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- cloud-painter
  [{:keys [args word-infos test-area]} g w h]
  (let [c (point (/ w 2.0) (/ h 2.0))
        bg (translate-area test-area c)]
    (doto g
      setup-graphics-context
      (fill-rect (rectangle 0 0 w h) :color (:background-color args)))
    (when (:debug args)
      (doto g
        (draw-rect (rectangle 0 0 (dec w) (dec h)))
        (fill-shape bg)
        (draw-shape bg)))
    (doseq [{:keys [text font color position rotation]} (filter #(not (nil? %)) word-infos)]
      (draw-string-centered g text (translate-point c position) :font font :color color :rotation rotation))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn paint-cloud
  [cloud args]
  (create-image (:width args) (:height args)
                (partial cloud-painter cloud)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-cloud
  [word-data &amp; {:as args}]
  (let [args (merge default-args args)
        word-infos (build-word-infos word-data args)
        cloud-info (build-cloud-info word-infos args)
        img (paint-cloud cloud-info args)
        target-file (:target-file args)]
    (when target-file (save-image img target-file))
    (assoc cloud-info :image img)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/fogus/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
       SyntaxHighlighter.all()</script></body></html>